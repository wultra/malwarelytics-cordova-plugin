//
// Copyright 2020 Wultra s.r.o.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions
// and limitations under the License.
//

package com.wultra.android.cordova.malwarelytics.plugin

import android.content.pm.PackageManager
import android.graphics.Bitmap
import android.graphics.drawable.BitmapDrawable
import android.util.Base64.encodeToString
import com.google.gson.Gson
import com.google.gson.annotations.SerializedName
import com.wultra.android.antimalware.AntivirusConfig
import com.wultra.android.antimalware.ThreatIndex
import com.wultra.android.appprotection.AppProtection
import com.wultra.android.appprotection.AppProtectionConfig
import com.wultra.android.rasp.*
import org.apache.cordova.CallbackContext
import org.apache.cordova.CordovaPlugin
import org.apache.cordova.PluginResult
import org.json.JSONArray
import org.json.JSONException
import org.json.JSONObject
import java.io.ByteArrayOutputStream
import java.lang.Exception
import java.util.*

class MalwarelyticsPlugin : CordovaPlugin() {

    private enum class Error {
        PLUGIN_UNKNOWN_ACTION,
        PLUGIN_ALREADY_INITIALIZED,
        PLUGIN_NOT_INITIALIZED,

        MISSING_ARGUMENTS,

        INITIALIZE_MISSING_CREDENTIALS,
        INITIALIZE_WRONG_CONFIG,

        TRIGGER_SMART_PROTECTION_UPDATE_FAILED,
        TRIGGER_SMART_PROTECTION_FAILED,

        UTILS_LANG_CHANGE_FAILED,

        THREAT_LIST_FAILED,

        APK_INFO_NOT_AVAILABLE,

        RASP_UNKNOWN_DETECTION
    }

    private enum class RaspDetection {
        ROOT_DETECTION,
        IS_ROOTED,
        IS_EMULATOR,
        EMULATOR_INFO,
        IS_DEBUGGER,
        DEBUGGER_INFO,
        REPACKAGE_INFO,
        IS_SCREEN_SHARED,
        SCREEN_SHARED_INFO,
        SCREEN_LOCK_ENABLED,
        PLAY_PROTECT_ENABLED,
        NOT_ALLOWED_SCREEN_READER_ENABLED,
        IS_BAD_TAPJACKING_CAPABLE_APP_PRESENT,
        TAPJACKING_INFO,
        HTTP_PROXY_INFO
    }

    private enum class RaspCallbackType {
        DEBUGGER,
        EMULATOR,
        REPACKAGING,
        ROOT,
        SCREEN_SHARING,
        TAPJACKING,
        HTTP_PROXY
    }

    private var appProtection: AppProtection? = null

    private var raspObserver: RaspObserver? = null
    private var raspCallbackContext: CallbackContext? = null

    @Throws(JSONException::class)
    override fun execute(action: String, args: JSONArray, callbackContext: CallbackContext): Boolean {
        
        if (action == "initialize") {
            val obj = args.getString(0)
            return try {
                val config = Gson().fromJson(obj, JsMalwarelyticsConfig::class.java)
                this.initialize(config, callbackContext)
                true
            } catch(e: Throwable) {
                callbackContext.error(Error.INITIALIZE_WRONG_CONFIG.name)
                false
            }
        }

        if (action == "isInitialized") {
            this.isInitialized(callbackContext)
            return true
        }

        if (action == "triggerSmartProtection") {
            this.triggerSmartProtection(callbackContext)
            return true
        }

        if (action == "setClientId") {
            val clientId: String? = if(args.isNull(0)) {
                null
            } else {
                args.getString(0)
            }
            this.setClientId(clientId, callbackContext)
            return true
        }

        if (action == "changeAppLanguage") {
            val lang: String? = if(args.isNull(0)) {
                null
            } else {
                args.getString(0)
            }
            setLanguage(lang, callbackContext)
            return true
        }

        if (action == "getThreatList") {
            getThreatList(callbackContext)
            return true
        }

        if (action == "getApkInfo") {
            val packageName = args.optString(0)
            return if (packageName != null) {
                getApkInfo(packageName, callbackContext)
                true
            } else {
                callbackContext.error(Error.MISSING_ARGUMENTS.name)
                false
            }
        }

        if (action == "raspInfo") {
            val info = args.optString(0)
            return if (info != null) {
                getRaspDetection(RaspDetection.valueOf(info), callbackContext)
                true
            } else {
                callbackContext.error(Error.MISSING_ARGUMENTS.name)
                false
            }
        }

        if (action == "setRaspCallback") {
            setRaspCallback(callbackContext)
            return true
        }

        if (action == "clearRaspCallback") {
            clearRaspCallback(callbackContext)
            return true
        }

        callbackContext.error(Error.PLUGIN_UNKNOWN_ACTION.name)

        return false
    }

    private fun isInitialized(callbackContext: CallbackContext? = null): Boolean {
        val result = this.appProtection?.isInitialized() ?: false
        callbackContext?.success(if (result) 1 else 0)
        return result
    }

    private fun initialize(config: JsMalwarelyticsConfig, callbackContext: CallbackContext) {

        cordova.threadPool.run {

            if (isInitialized()) {
                callbackContext.error(Error.PLUGIN_ALREADY_INITIALIZED.name)
                return
            }

            val username = MalwarelyticsConfig.USER_NAME
            val password = MalwarelyticsConfig.PASSWORD

            if (password == "" || username == "") {
                callbackContext.error(Error.INITIALIZE_MISSING_CREDENTIALS.name)
                return
            }

            val context = cordova.activity

            val spb = AntivirusConfig.SmartProtectionConfig.Builder()
                .silentModeEnabled(config.antivirus?.enableSilentMode ?: true)
                .performInitialFirstUpdate(config.antivirus?.updateOnInitialize ?: true)
                .smartProtectionIntervalHours(config.antivirus?.onlineCheckIntervalHours ?: 48)

            val rb = RaspConfig.Builder()
            config.rasp?.checkEmulator?.let { rb.checkEmulator(it) }
            config.rasp?.exitOnEmulator?.let { rb.exitOnEmulator(it) }
            config.rasp?.checkRoot?.let { rb.checkRoot(it) }
            config.rasp?.exitOnRoot?.let { rb.exitOnRoot(it) }
            config.rasp?.exitOnRootMinConfidence?.let { rb.exitOnRootMinConfidence(it) }
            config.rasp?.checkDebugger?.let { rb.checkDebugger(it) }
            config.rasp?.exitOnDebugger?.let { rb.exitOnDebugger(it) }
            config.rasp?.checkRepackaging?.let { rb.checkRepackaging(it) }
            config.rasp?.exitOnRepackaging?.let { rb.exitOnRepackaging(it) }
            config.rasp?.signatureHash?.let { rb.signatureHash(it) }
            config.rasp?.exitOnScreenSharing?.let { rb.exitOnScreenSharing(it) }
            config.rasp?.blockScreenshots?.let { rb.blockScreenshots(it) }
            config.rasp?.blockScreenReaders?.let { rb.blockScreenReaders(it) }
            config.rasp?.allowedScreenReaders?.let { readers -> rb.allowedScreenReaders(readers.map { it.toApkAllowList() }) }
            config.rasp?.customProcessName?.let { rb.customProcessName(it) }
            config.rasp?.useStealthyProcessName?.let { rb.useStealthyProcessName(it) }
            config.rasp?.blockTapjacking?.let { rb.blockTapjacking(it) }
            config.rasp?.blockTapjackingSensitivity?.let { rb.blockTapjackingSensitivity(it.toThreatIndex()) }

            val tmBuilder = AntivirusConfig.ThreatMitigationUIConfig.Builder()
            MalwarelyticsConfig.THEME?.let { tmBuilder.screenTheme(it) }
            MalwarelyticsConfig.NOTIFICATION_ICON?.let { tmBuilder.notificationSmallIcon(it) }
            MalwarelyticsConfig.SETTINGS_ICON?.let { tmBuilder.screenSettingsIcon(it) }
            MalwarelyticsConfig.DELETE_ICON?.let { tmBuilder.screenDeleteIcon(it) }
            config.languageCode?.let { tmBuilder.customLocalization(it) }

            val avConfigBuilder = AntivirusConfig.Builder().smartProtectionConfig(spb.build())
            avConfigBuilder.threatMitigationUIConfig(tmBuilder.build())

            val builder = AppProtectionConfig.Builder(context)
                .antivirusConfig(avConfigBuilder.build())
                .raspConfig(rb.build())
                .apiUsername(username)
                .apiPassword(password)

            MalwarelyticsConfig.API_PUBLIC_KEY?.let { builder.apiSignaturePublicKey(it) }
            config.clientId?.let { builder.clientAppUserId(it) }

            val appProtection = AppProtection.getInstance()
            this@MalwarelyticsPlugin.appProtection = appProtection
            appProtection.initializeAsync(builder.build(), object : AppProtection.InitializationObserver {
                override fun onInitialized() {
                    callbackContext.success()
                }
            })
        }
    }

    private fun setClientId(clientId: String?, callbackContext: CallbackContext) {

        if (!this.isInitialized()) {
            callbackContext.error(Error.PLUGIN_NOT_INITIALIZED.name)
            return
        }

        this.appProtection!!.updateClientAppUserId(clientId)
        callbackContext.success()
    }

    private fun setLanguage(language: String?, callbackContext: CallbackContext) {
        if (!this.isInitialized()) {
            callbackContext.error(Error.PLUGIN_NOT_INITIALIZED.name)
            return
        }
        if (language != null) {
            this.appProtection!!.getAntivirus().getSmartProtectionManager().setCustomLocalization(language)
            callbackContext.success()
        } else {
            callbackContext.error(Error.UTILS_LANG_CHANGE_FAILED.name)
        }
    }

    private fun triggerSmartProtection(callbackContext: CallbackContext) {
        cordova.threadPool.run {
            if (!isInitialized()) {
                callbackContext.error(Error.PLUGIN_NOT_INITIALIZED.name)
            } else {
                val updateResult = appProtection!!.getAntivirus().getSmartProtectionManager().performSingleSmartProtectionUpdate()
                if (!updateResult.onlineUpdateSucceeded) {
                    callbackContext.error(Error.TRIGGER_SMART_PROTECTION_UPDATE_FAILED.name)
                } else if (!updateResult.evaluationSucceeded) {
                    callbackContext.error(Error.TRIGGER_SMART_PROTECTION_FAILED.name)
                } else {
                    callbackContext.success()
                }
            }
        }
    }

    private fun getThreatList(callbackContext: CallbackContext) {
        cordova.threadPool.run {
            if (!isInitialized()) {
                callbackContext.error(Error.PLUGIN_NOT_INITIALIZED.name)
            } else {
                try {
                    val list = appProtection!!.getAntivirus().evaluateThreats()
                    val response = JSONObject()
                    response.put("items", JSONArray(list.map { t ->
                        val o = JSONObject()
                        o.put("evaluatedThreatIndex", t.evaluatedThreatIndex.name)
                        o.put("malwareDetectionName", t.malwareDetectionName ?: JSONObject.NULL)
                        o.put("mitigations", JSONArray(t.mitigations.map { it.name }))
                        o.put("packageName", t.packageName)
                        o.put("reasons", JSONArray(t.reasons.map { it.name }))
                        o.put("suggestedThreatIndex", t.suggestedThreatIndex.name)
                        o.put("threatIndex", t.threatIndex.name)
                        o.put("threatInstaller", t.threatInstaller?.name ?: JSONObject.NULL)
                        return@map o
                    }
                    ))
                    callbackContext.success(response)
                } catch (e: Exception) {
                    callbackContext.error(Error.THREAT_LIST_FAILED.name)
                }
            }
        }
    }

    private fun getApkInfo(packageName: String, callbackContext: CallbackContext) {
        cordova.threadPool.run {
            if (!isInitialized()) {
                callbackContext.error(Error.PLUGIN_NOT_INITIALIZED.name)
            } else {
                try {
                    val pm = cordova.activity.packageManager
                    val label = pm.getApplicationLabel(pm.getApplicationInfo(packageName, PackageManager.GET_META_DATA))
                    val icon = (pm.getApplicationIcon(packageName) as? BitmapDrawable)?.let { bd ->
                        val stream = ByteArrayOutputStream()
                        bd.bitmap.compress(Bitmap.CompressFormat.PNG, 100, stream)
                        return@let encodeToString(stream.toByteArray(), android.util.Base64.DEFAULT)
                    }
                    val o = JSONObject()
                    o.put("label", label)
                    o.put("icon", icon ?: JSONObject.NULL)
                    callbackContext.success(o)
                } catch (e: Exception) {
                    callbackContext.error(Error.APK_INFO_NOT_AVAILABLE.name)
                }
            }
        }
    }

    private fun getRaspDetection(detection: RaspDetection, callbackContext: CallbackContext) {
        cordova.threadPool.run {

            if (!isInitialized()) {
                callbackContext.error(Error.PLUGIN_NOT_INITIALIZED.name)
                return
            }

            val rm = appProtection!!.getRaspManager()
            when (detection) {
                RaspDetection.ROOT_DETECTION -> {
                    callbackContext.success(rm.getRootDetection().toJson())
                }
                RaspDetection.IS_ROOTED -> {
                    callbackContext.success(if (rm.isDeviceRooted()) 1 else 0)
                }
                RaspDetection.EMULATOR_INFO -> {
                    callbackContext.success(rm.getEmulatorDetection().toJson())
                }
                RaspDetection.IS_EMULATOR -> {
                    callbackContext.success(if (rm.isDeviceEmulator()) 1 else 0)
                }
                RaspDetection.DEBUGGER_INFO -> {
                    val dd = rm.getDebuggerDetection()
                    val o = JSONObject()
                    o.put("isDebuggerAttached", dd.isDebuggerAttached)
                    o.put("isWaitingForDebugger", dd.isWaitingForDebugger)
                    o.put("debuggerType", JSONArray(dd.debbuggerType.map { it.name }))
                    callbackContext.success(o)
                }
                RaspDetection.IS_DEBUGGER -> {
                    callbackContext.success(if (rm.isDebuggerAttached()) 1 else 0)
                }
                RaspDetection.REPACKAGE_INFO -> {
                    callbackContext.success(rm.isAppRepackaged().name)
                }
                RaspDetection.SCREEN_SHARED_INFO -> {
                    val sd = rm.getScreenSharingDetection()
                    val o = JSONObject()
                    o.put("isScreenShared", sd.isScreenShared)
                    o.put("numberOfDisplays", sd.numberOfDisplays)
                    callbackContext.success(o)
                }
                RaspDetection.IS_SCREEN_SHARED -> {
                    callbackContext.success(if (rm.isScreenShared()) 1 else 0)
                }
                RaspDetection.SCREEN_LOCK_ENABLED -> {
                    callbackContext.success(if (rm.isDeviceUsingScreenLock()) 1 else 0)
                }
                RaspDetection.PLAY_PROTECT_ENABLED -> {
                    callbackContext.success(if (rm.isPlayProtectEnabled() == true) 1 else 0)
                }
                RaspDetection.NOT_ALLOWED_SCREEN_READER_ENABLED -> {
                    callbackContext.success(if (rm.isNotAllowedScreenReaderEnabled()) 1 else 0)
                }
                RaspDetection.IS_BAD_TAPJACKING_CAPABLE_APP_PRESENT -> {
                    callbackContext.success(if (rm.isBadTapjackingCapableAppPresent()) 1 else 0)
                }
                RaspDetection.TAPJACKING_INFO -> {
                    callbackContext.success(rm.getTapjackingDetection().toJson())
                }
                RaspDetection.HTTP_PROXY_INFO -> {
                    callbackContext.success(rm.getHttpProxyDetection().toJson())
                }
                else -> {
                    callbackContext.error(Error.RASP_UNKNOWN_DETECTION.name)
                }
            }
        }
    }

    private fun setRaspCallback(callbackContext: CallbackContext) {

        fun prepareObject(type: RaspCallbackType): JSONObject {
            return JSONObject().also { it.put("type", type.name) }
        }

        fun resolve(jsonObject: JSONObject) {
            cordova.threadPool.run {
                raspCallbackContext?.sendPluginResult(PluginResult(PluginResult.Status.OK, jsonObject).also { it.keepCallback = true })
            }
        }

        clearRaspCallback(null)
        raspCallbackContext = callbackContext
        raspObserver = object : RaspObserver {

            private val payloadProperty = "payload"

            override fun onDebuggerDetected(debuggerDetected: Boolean) {
                val o = prepareObject(RaspCallbackType.DEBUGGER).also { it.put(payloadProperty, debuggerDetected) }
                resolve(o)
            }

            override fun onEmulatorDetected(emulatorDetection: EmulatorDetection) {
                val o = prepareObject(RaspCallbackType.EMULATOR).also { it.put(payloadProperty, emulatorDetection.toJson()) }
                resolve(o)
            }

            override fun onRepackagingDetected(repackagingResult: RepackagingResult) {
                val o = prepareObject(RaspCallbackType.REPACKAGING).also { it.put(payloadProperty, repackagingResult.name) }
                resolve(o)
            }

            override fun onRootDetected(rootDetection: RootDetection) {
                val o = prepareObject(RaspCallbackType.ROOT).also { it.put(payloadProperty, rootDetection.toJson()) }
                resolve(o)
            }

            override fun onScreenSharingDetected(screenSharingDetected: Boolean) {
                val o = prepareObject(RaspCallbackType.SCREEN_SHARING).also { it.put(payloadProperty, screenSharingDetected) }
                resolve(o)
            }

            override fun onTapjackingDetected(tapjackingDetection: TapjackingDetection) {
                val o = prepareObject(RaspCallbackType.TAPJACKING).also { it.put(payloadProperty, tapjackingDetection.toJson()) }
                resolve(o)
            }

            override fun onHttpProxyDetected(httpProxyDetection: HttpProxyDetection) {
                val o = prepareObject(RaspCallbackType.HTTP_PROXY).also { it.put(payloadProperty, httpProxyDetection.toJson()) }
                resolve(o)
            }

        }.also { appProtection!!.getRaspManager().registerRaspObserver(it) }
    }

    private fun clearRaspCallback(callbackContext: CallbackContext?) {
        val result = PluginResult(PluginResult.Status.NO_RESULT, "Rasp Callback Cleared")
        result.keepCallback = false
        raspCallbackContext?.sendPluginResult(result)
        raspObserver?.let { appProtection!!.getRaspManager().unregisterRaspObserver(it) }
        raspObserver = null
        callbackContext?.success()
    }
}

data class JsMalwarelyticsConfig(val clientId: String?,
                                 val languageCode: String?,
                                 val antivirus: JsAntivirusConfig?,
                                 val rasp: JsRaspConfig?)

data class JsAntivirusConfig(val enableSilentMode: Boolean?,
                             val onlineCheckIntervalHours: Int?,
                             val updateOnInitialize: Boolean?)

data class JsRaspConfig(val checkEmulator: Boolean?,
                        val exitOnEmulator: Boolean?,
                        val checkRoot: Boolean?,
                        val exitOnRoot: Boolean?,
                        val exitOnRootMinConfidence: Float?,
                        val checkDebugger: Boolean?,
                        val exitOnDebugger: Boolean?,
                        val checkRepackaging: Boolean?,
                        val exitOnRepackaging: Boolean?,
                        val signatureHash: String?,
                        val checkScreenSharing: Boolean?,
                        val exitOnScreenSharing: Boolean?,
                        val blockScreenshots: Boolean?,
                        val blockScreenReaders: Boolean?,
                        val allowedScreenReaders: Array<JsApk>?,
                        val customProcessName: String?,
                        val useStealthyProcessName: Boolean?,
                        val blockTapjacking: Boolean?,
                        val blockTapjackingSensitivity: JSThreatIndex?
)

enum class JSThreatIndex {
    @SerializedName("UNKNOWN")
    UNKNOWN,
    @SerializedName("SAFE")
    SAFE,
    @SerializedName("POTENTIALLY_UNWANTED_APP")
    POTENTIALLY_UNWANTED_APP,
    @SerializedName("DANGEROUS")
    DANGEROUS,
    @SerializedName("HIGHLY_DANGEROUS")
    HIGHLY_DANGEROUS,
    @SerializedName("MALWARE")
    MALWARE;

    fun toThreatIndex(): ThreatIndex {
        return when(this) {
            UNKNOWN -> ThreatIndex.UNKNOWN
            SAFE -> ThreatIndex.SAFE
            POTENTIALLY_UNWANTED_APP -> ThreatIndex.POTENTIALLY_UNWANTED_APP
            DANGEROUS -> ThreatIndex.DANGEROUS
            HIGHLY_DANGEROUS -> ThreatIndex.HIGHLY_DANGEROUS
            MALWARE -> ThreatIndex.MALWARE
        }
    }
}

data class JsApk(val packageName: String, val signatureHash: String? = null) {
    fun toApkAllowList() = RaspConfig.ApkAllowlist(packageName, signatureHash)
}

private fun EmulatorDetection.toJson(): JSONObject {
    val o = JSONObject()
    o.put("isEmulator", isEmulator)
    detectedEmulatorType?.let { o.put("detectedEmulatorType", it) }
    return o
}

private fun RootDetection.toJson(): JSONObject {
    val o = JSONObject()
    o.put("isRooted", isRooted)
    o.put("isRootCloaked", isRootCloaked)
    o.put("rootCloakDetectionConfidence", rootCloakDetectionConfidence)
    o.put("rootDetectionConfidence", rootDetectionConfidence)
    o.put("rootDetectionProofs", JSONArray(rootDetectionProofs.map { it.name }))
    return o
}

private fun TapjackingDetection.toJson(): JSONObject {
    val o = JSONObject()
    o.put("isTapjackingBlocked", isTapjackingBlocked)
    o.put("tapjackingCapableApps", JSONArray(tapjackingCapableApps))
    return o
}

private fun HttpProxyDetection.toJson(): JSONObject {
    val o = JSONObject()
    o.put("isHttpProxyEnabled", isHttpProxyEnabled)
    o.put("isUsingAutoConfig", isUsingAutoConfig())
    o.put("host", host)
    o.put("port", port)
    o.put("exclusionList", exclusionList)
    o.put("pacFileUrl", pacFileUrl?.toString())
    return o
}