//
// Copyright 2023 Wultra s.r.o.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions
// and limitations under the License.
//

package com.wultra.android.cordova.malwarelytics.plugin

import android.content.pm.PackageManager
import android.graphics.Bitmap
import android.graphics.drawable.BitmapDrawable
import android.util.Base64.encodeToString
import com.google.gson.Gson
import com.google.gson.annotations.SerializedName
import com.wultra.android.antimalware.AntivirusConfig
import com.wultra.android.antimalware.ApkThreat
import com.wultra.android.antimalware.MalwareFlag
import com.wultra.android.antimalware.ThreatIndex
import com.wultra.android.antimalware.update.*
import com.wultra.android.appprotection.AppProtection
import com.wultra.android.appprotection.AppProtectionConfig
import com.wultra.android.appprotection.AppProtectionConfig.FingerprintType
import com.wultra.android.rasp.*
import com.wultra.android.rasp.config.*
import com.wultra.android.rasp.config.AppPresenceDetectionConfig.NamedApkItem
import org.apache.cordova.CallbackContext
import org.apache.cordova.CordovaPlugin
import org.apache.cordova.PluginResult
import org.json.JSONArray
import org.json.JSONException
import org.json.JSONObject
import java.io.ByteArrayOutputStream
import java.lang.Exception
import java.util.*

class MalwarelyticsPlugin : CordovaPlugin() {

    private enum class Error {
        PLUGIN_UNKNOWN_ACTION,
        PLUGIN_ALREADY_INITIALIZED,
        PLUGIN_NOT_INITIALIZED,

        MISSING_ARGUMENTS,

        INITIALIZE_MISSING_CREDENTIALS,
        INITIALIZE_WRONG_CONFIG,
        INITIALIZE_WRONG_ENVIRONMENT,

        TRIGGER_SMART_PROTECTION_UPDATE_FAILED,
        TRIGGER_SMART_PROTECTION_FAILED,

        UTILS_LANG_CHANGE_FAILED,

        THREAT_LIST_FAILED,

        APK_INFO_NOT_AVAILABLE,

        RASP_UNKNOWN_DETECTION
    }

    private enum class RaspDetection {
        // OBSERVABLE FEATURES

        /* root */
        IS_ROOTED,
        ROOT_DETECTION,

        /* emulator */
        IS_EMULATOR,
        EMULATOR_INFO,
        
        /* debugger */
        IS_DEBUGGER,
        DEBUGGER_INFO,

        /* repackaging */
        REPACKAGE_INFO,

        /* screen sharing */
        IS_SCREEN_SHARED,
        SCREEN_SHARED_INFO,

        /* tapjacking */
        IS_BAD_TAPJACKING_CAPABLE_APP_PRESENT,
        TAPJACKING_INFO,

        /* http proxy */
        HTTP_PROXY_INFO,
        IS_HTTP_PROXY,

        /* VPN */
        IS_VPN,

        /* ADB status */
        ADB_STATUS,

        /* active call */
        IS_ACTIVE_CALL,
        ACTIVE_CALL_INFO,

        /* app presence */
        APP_PRESENCE_INFO,

        // PASSIVE FEATURES

        /* screen reader */
        NOT_ALLOWED_SCREEN_READER_ENABLED,
        SCREEN_READER_INFO,

        // INFO FEATURES

        /* screen lock */
        SCREEN_LOCK_ENABLED,

        /* biometry */
        BIOMETRY,

        /* play protect */
        PLAY_PROTECT_ENABLED,

        /* developer options */
        DEVELOPER_OPTIONS
    }

    private enum class RaspCallbackType {
        DEBUGGER,
        EMULATOR,
        REPACKAGING,
        ROOT,
        SCREEN_SHARING,
        SCREEN_READER,
        TAPJACKING,
        HTTP_PROXY,
        VPN,
        ADB_STATUS,
        ACTIVE_CALL,
        APP_PRESENCE
    }

    private var appProtection: AppProtection? = null

    private var updateObserver: UpdateObserver? = null
    private var updateCallbackContext: CallbackContext? = null
    private var raspObserver: RaspObserver? = null
    private var raspCallbackContext: CallbackContext? = null

    @Throws(JSONException::class)
    override fun execute(action: String, args: JSONArray, callbackContext: CallbackContext): Boolean {
        
        if (action == "initialize") {
            val obj = args.getString(0)
            return try {
                val config = Gson().fromJson(obj, JsMalwarelyticsConfig::class.java)
                this.initialize(config, callbackContext)
                true
            } catch(e: Throwable) {
                callbackContext.error(Error.INITIALIZE_WRONG_CONFIG.name)
                false
            }
        }

        if (action == "isInitialized") {
            this.isInitialized(callbackContext)
            return true
        }

        if (action == "triggerSmartProtection") {
            val performOnlineUpdate: Boolean = if (args.isNull(0)) {
                true
            } else {
                args.getBoolean(0)
            }
            this.triggerSmartProtection(performOnlineUpdate, callbackContext)
            return true
        }

        if (action == "setClientId") {
            val clientId: String? = if(args.isNull(0)) {
                null
            } else {
                args.getString(0)
            }
            this.setClientId(clientId, callbackContext)
            return true
        }

        if (action == "setDeviceId") {
            val deviceId: String? = if(args.isNull(0)) {
                null
            } else {
                args.getString(0)
            }
            this.setDeviceId(deviceId, callbackContext)
            return true
        }

        if (action == "changeAppLanguage") {
            val lang: String? = if(args.isNull(0)) {
                null
            } else {
                args.getString(0)
            }
            setLanguage(lang, callbackContext)
            return true
        }

        if (action == "getInitializationResult") {
            getInitialzationResult(callbackContext)
            return true
        }

        if (action == "getThreatList") {
            getThreatList(callbackContext)
            return true
        }

        if (action == "getApkInfo") {
            val packageName = args.optString(0)
            return if (packageName != null) {
                getApkInfo(packageName, callbackContext)
                true
            } else {
                callbackContext.error(Error.MISSING_ARGUMENTS.name)
                false
            }
        }

        if (action == "getLastUpdateInfo") {
            getLastUpdateInfo(callbackContext)
            return true
        }

        if (action == "setUpdateCallback") {
            setUpdateCallback(callbackContext)
            return true
        }

        if (action == "clearUpdateCallback") {
            clearUpdateCallback(callbackContext)
            return true
        }

        if (action == "raspInfo") {
            val info = args.optString(0)
            return if (info != null) {
                getRaspDetection(RaspDetection.valueOf(info), callbackContext)
                true
            } else {
                callbackContext.error(Error.MISSING_ARGUMENTS.name)
                false
            }
        }

        if (action == "setRaspCallback") {
            setRaspCallback(callbackContext)
            return true
        }

        if (action == "clearRaspCallback") {
            clearRaspCallback(callbackContext)
            return true
        }

        callbackContext.error(Error.PLUGIN_UNKNOWN_ACTION.name)

        return false
    }

    private fun isInitialized(callbackContext: CallbackContext? = null): Boolean {
        val result = this.appProtection?.isInitialized() ?: false
        callbackContext?.success(if (result) 1 else 0)
        return result
    }

    private fun initialize(config: JsMalwarelyticsConfig, callbackContext: CallbackContext) {

        cordova.threadPool.execute(Runnable {

            if (isInitialized()) {
                callbackContext.error(Error.PLUGIN_ALREADY_INITIALIZED.name)
                return@Runnable
            }

            val username = MalwarelyticsConfig.USER_NAME
            val password = MalwarelyticsConfig.PASSWORD

            if (password == "" || username == "") {
                callbackContext.error(Error.INITIALIZE_MISSING_CREDENTIALS.name)
                return@Runnable
            }

            val context = cordova.activity

            val cg = AppProtectionConfig.CustomerGroupingConfig.Builder()
            config.androidConfig?.customerGroupingConfig?.sourcePackageName?.let { cg.sourcePackageName(it) }
            config.androidConfig?.customerGroupingConfig?.appPackageName?.let { cg.appPackageName(it) }
            config.androidConfig?.customerGroupingConfig?.audienceGroupId?.let { cg.audienceGroupId(it) }

            val spb = AntivirusConfig.SmartProtectionConfig.Builder()
                .silentModeEnabled(config.androidConfig?.antivirusConfig?.enableSilentMode ?: true)
                .performInitialFirstUpdate(config.androidConfig?.antivirusConfig?.updateOnInitialize ?: true)
                .smartProtectionIntervalHours(config.androidConfig?.antivirusConfig?.onlineCheckIntervalHours ?: 48)

            val rb = RaspConfig.Builder()
            config.androidConfig?.raspConfig?.let {
                it.emulator?.let { jsCfg ->
                    rb.emulator(jsCfg.toDetectionConfig())
                }
                it.root?.let { jsCfg ->
                    rb.root(jsCfg.toRootDetectionConfig())
                }
                it.debugger?.let { jsCfg ->
                    rb.debugger(jsCfg.toDebuggerDetectionConfig())
                }
                it.repackage?.let { jsCfg ->
                    rb.repackage(jsCfg.toRepackageDetectionConfig())
                }
                it.screenSharing?.let { jsCfg ->
                    rb.screenSharing(jsCfg.toDetectionConfig())
                }
                it.screenshot?.let { jsCfg ->
                    rb.screenshot(jsCfg.toBlockConfig())
                }
                it.screenReader?.let { jsCfg ->
                    rb.screenReader(jsCfg.toScreenReaderBlockConfig())
                }
                it.processName?.let { jsCfg ->
                    rb.processName(jsCfg.toProcessNameConfig())
                }
                it.tapjacking?.let { jsCfg ->
                    rb.tapjacking(jsCfg.toTapjackingBlockConfig())
                }
                it.httpProxy?.let { jsCfg ->
                    rb.httpProxy(jsCfg.toDetectionConfig())
                }
                it.vpn?.let { jsCfg ->
                    rb.vpn(jsCfg.toDetectionConfig())
                }
                it.adb?.let { jsCfg ->
                    rb.adb(jsCfg.toAdbDetectionConfig())
                }
                it.activeCall?.let { jsCfg ->
                    rb.activeCall(jsCfg.toSimpleDetectinConfig())
                }
                it.appPresence?.let { jsCfg ->
                    rb.appPresence(jsCfg.toAppPresenceDetectionConfig())
                }
            }

            val tmBuilder = AntivirusConfig.ThreatMitigationUIConfig.Builder()
            MalwarelyticsConfig.THEME?.let { tmBuilder.screenTheme(it) }
            MalwarelyticsConfig.NOTIFICATION_ICON?.let { tmBuilder.notificationSmallIcon(it) }
            MalwarelyticsConfig.SETTINGS_ICON?.let { tmBuilder.screenSettingsIcon(it) }
            MalwarelyticsConfig.DELETE_ICON?.let { tmBuilder.screenDeleteIcon(it) }
            config.androidConfig?.languageCode?.let { tmBuilder.customLocalization(it) }

            val avConfigBuilder = AntivirusConfig.Builder().smartProtectionConfig(spb.build())
            avConfigBuilder.threatMitigationUIConfig(tmBuilder.build())

            val builder = AppProtectionConfig.Builder(context)
                .antivirusConfig(avConfigBuilder.build())
                .raspConfig(rb.build())
                .customerGroupingConfig(cg.build())
                .apiUsername(username)
                .apiPassword(password)

            config.androidConfig?.fingerprint?.let { jsFingerprint ->
                builder.fingerprint(jsFingerprint.toFingerprintType())
            }

            when (MalwarelyticsConfig.ENVIRONMENT) {
                "PRODUCTION" -> builder.environment(AppProtectionConfig.EnvironmentConfiguration.PRODUCTION_ENVIRONMENT)
                "TEST" -> builder.environment(AppProtectionConfig.EnvironmentConfiguration.TEST_ENVIRONMENT)
                else -> {
                    callbackContext.error(Error.INITIALIZE_WRONG_ENVIRONMENT.name)
                    return@Runnable
                }
            }

            MalwarelyticsConfig.API_PUBLIC_KEY?.let { builder.apiSignaturePublicKey(it) }
            config.clientId?.let { builder.clientAppUserId(it) }
            config.deviceId?.let { builder.clientAppDeviceId(it) }

            val appProtection = AppProtection.getInstance()
            this@MalwarelyticsPlugin.appProtection = appProtection
            appProtection.initializeAsync(builder.build(), object : AppProtection.InitializationObserver {
                override fun onInitialized(initializationResult: AppProtection.InitializationResult) {
                    callbackContext.success(initializationResult.name)
                }
            })
        })
    }

    private fun getInitialzationResult(callbackContext: CallbackContext) {
        val result = this.appProtection!!.getInitializationResult()
        if (result == null) {
            callbackContext.error(Error.PLUGIN_NOT_INITIALIZED.name)
        } else {
            callbackContext.success(result.name)
        }
    }

    private fun setClientId(clientId: String?, callbackContext: CallbackContext) {
        if (!this.isInitialized()) {
            callbackContext.error(Error.PLUGIN_NOT_INITIALIZED.name)
            return
        }

        this.appProtection!!.updateClientAppUserId(clientId)
        callbackContext.success()
    }

    private fun setDeviceId(deviceId: String?, callbackContext: CallbackContext) {

        if (!this.isInitialized()) {
            callbackContext.error(Error.PLUGIN_NOT_INITIALIZED.name)
            return
        }

        this.appProtection!!.updateClientAppDeviceId(deviceId)
        callbackContext.success()
    }

    private fun setLanguage(language: String?, callbackContext: CallbackContext) {
        if (!this.isInitialized()) {
            callbackContext.error(Error.PLUGIN_NOT_INITIALIZED.name)
            return
        }
        if (language != null) {
            this.appProtection!!.getAntivirus().getSmartProtectionManager().setCustomLocalization(language)
            callbackContext.success()
        } else {
            callbackContext.error(Error.UTILS_LANG_CHANGE_FAILED.name)
        }
    }

    private fun triggerSmartProtection(performOnlineUpdate: Boolean, callbackContext: CallbackContext) {
        cordova.threadPool.execute(Runnable {
            if (!isInitialized()) {
                callbackContext.error(Error.PLUGIN_NOT_INITIALIZED.name)
            } else {
                val updateResult = appProtection!!.getAntivirus().getSmartProtectionManager().performSingleSmartProtectionUpdate(performOnlineUpdate)
                val o = JSONObject()
                o.put("uiDisplayed", updateResult.uiDisplayed)
                o.put("onlineUpdateSucceeded", updateResult.onlineUpdateSucceeded)
                o.put("evaluationSucceeded", updateResult.evaluationSucceeded)
                callbackContext.success(o)
            }
        })
    }

    private fun getThreatList(callbackContext: CallbackContext) {
        cordova.threadPool.execute(Runnable {
            if (!isInitialized()) {
                callbackContext.error(Error.PLUGIN_NOT_INITIALIZED.name)
            } else {
                try {
                    val list = appProtection!!.getAntivirus().evaluateThreats()
                    val items = JSONArray(list.map { t -> t.toJson() })
                    val response = JSONObject()
                    response.put("items", items)
                    callbackContext.success(response)
                } catch (e: Exception) {
                    callbackContext.error(Error.THREAT_LIST_FAILED.name)
                }
            }
        })
    }

    private fun getApkInfo(packageName: String, callbackContext: CallbackContext) {
        cordova.threadPool.execute(Runnable {
            if (!isInitialized()) {
                callbackContext.error(Error.PLUGIN_NOT_INITIALIZED.name)
            } else {
                try {
                    val pm = cordova.activity.packageManager
                    @Suppress("DEPRECATION") 
                    val label = pm.getApplicationLabel(pm.getApplicationInfo(packageName, PackageManager.GET_META_DATA))
                    val icon = (pm.getApplicationIcon(packageName) as? BitmapDrawable)?.let { bd ->
                        val stream = ByteArrayOutputStream()
                        bd.bitmap.compress(Bitmap.CompressFormat.PNG, 100, stream)
                        return@let encodeToString(stream.toByteArray(), android.util.Base64.DEFAULT)
                    }
                    val o = JSONObject()
                    o.put("label", label)
                    o.put("icon", icon ?: JSONObject.NULL)
                    callbackContext.success(o)
                } catch (e: Exception) {
                    callbackContext.error(Error.APK_INFO_NOT_AVAILABLE.name)
                }
            }
        })
    }

    private fun getLastUpdateInfo(callbackContext: CallbackContext) {
        val updateInfo = this.appProtection!!.getAntivirus().getUpdateManager().getLastUpdateInfo()
        callbackContext.success(updateInfo.toJson())
    }

    private fun setUpdateCallback(callbackContext: CallbackContext) {
        fun resolve(jsonObject: JSONObject) {
            cordova.threadPool.execute(Runnable {
                updateCallbackContext?.sendPluginResult(PluginResult(PluginResult.Status.OK, jsonObject).also { it.keepCallback = true })
            })
        }

        clearUpdateCallback(null)
        updateCallbackContext = callbackContext
        updateObserver = object : UpdateObserver {

            private val payloadProperty = "payload"

            override fun onSuggestionUpdated(observedUpdateInfo: ObservedUpdateInfo) {
                val o = JSONObject()
                o.put(payloadProperty, observedUpdateInfo.toJson())
                resolve(o)
            }
        }.also {
            appProtection!!.getAntivirus().getUpdateManager().registerUpdateObserver(it)
        }
    }

    private fun clearUpdateCallback(callbackContext: CallbackContext?) {
        val result = PluginResult(PluginResult.Status.NO_RESULT, "Update Callback Cleared")
        result.keepCallback = false
        updateCallbackContext?.sendPluginResult(result)
        updateObserver?.let { appProtection!!.getAntivirus().getUpdateManager().unregisterUpdateObserver(it) }
        updateObserver = null
        callbackContext?.success()
    }

    private fun getRaspDetection(detection: RaspDetection, callbackContext: CallbackContext) {
        cordova.threadPool.execute(Runnable {

            if (!isInitialized()) {
                callbackContext.error(Error.PLUGIN_NOT_INITIALIZED.name)
                return@Runnable
            }

            val rm = appProtection!!.getRaspManager()
            when (detection) {

                // OBSERVABLE FEATURE

                RaspDetection.IS_ROOTED -> {
                    callbackContext.success(if (rm.isDeviceRooted()) 1 else 0)
                }
                RaspDetection.ROOT_DETECTION -> {
                    callbackContext.success(rm.getRootDetection().toJson())
                }
                RaspDetection.IS_EMULATOR -> {
                    callbackContext.success(if (rm.isDeviceEmulator()) 1 else 0)
                }
                RaspDetection.EMULATOR_INFO -> {
                    callbackContext.success(rm.getEmulatorDetection().toJson())
                }
                RaspDetection.DEBUGGER_INFO -> {
                    callbackContext.success(rm.getDebuggerDetection().toJson())
                }
                RaspDetection.IS_DEBUGGER -> {
                    callbackContext.success(if (rm.isDebuggerAttached()) 1 else 0)
                }
                RaspDetection.REPACKAGE_INFO -> {
                    callbackContext.success(rm.isAppRepackaged().name)
                }
                RaspDetection.IS_SCREEN_SHARED -> {
                    callbackContext.success(if (rm.isScreenShared()) 1 else 0)
                }
                RaspDetection.SCREEN_SHARED_INFO -> {
                    callbackContext.success(rm.getScreenSharingDetection().toJson())
                }
                RaspDetection.IS_BAD_TAPJACKING_CAPABLE_APP_PRESENT -> {
                    callbackContext.success(if (rm.isBadTapjackingCapableAppPresent()) 1 else 0)
                }
                RaspDetection.TAPJACKING_INFO -> {
                    callbackContext.success(rm.getTapjackingDetection().toJson())
                }
                RaspDetection.IS_HTTP_PROXY -> {
                    callbackContext.success(if (rm.isHttpProxyEnabled()) 1 else 0)
                }
                RaspDetection.HTTP_PROXY_INFO -> {
                    callbackContext.success(rm.getHttpProxyDetection().toJson())
                }
                RaspDetection.IS_VPN -> {
                    callbackContext.success(if (rm.isVpnEnabled()) 1 else 0)
                }
                RaspDetection.ADB_STATUS -> {
                    callbackContext.success(if (rm.isAdbEnabled()) 1 else 0)
                }
                RaspDetection.IS_ACTIVE_CALL -> {
                    callbackContext.success(if (rm.isCallActive()) 1 else 0)
                }
                RaspDetection.ACTIVE_CALL_INFO -> {
                    callbackContext.success(rm.getActiveCallDetection().toJson())
                }
                RaspDetection.APP_PRESENCE_INFO -> {
                    callbackContext.success(rm.getAppPresenceDetection().toJson())
                }

                // PASSIVE FEATURES

                RaspDetection.NOT_ALLOWED_SCREEN_READER_ENABLED -> {
                    callbackContext.success(if (rm.isNotAllowedScreenReaderEnabled()) 1 else 0)
                }
                RaspDetection.SCREEN_READER_INFO -> {
                    callbackContext.success(rm.getScreenReaderDetection().toJson())
                }

                // INFO FEATURES

                RaspDetection.SCREEN_LOCK_ENABLED -> {
                    callbackContext.success(if (rm.isDeviceUsingScreenLock()) 1 else 0)
                }
                RaspDetection.BIOMETRY -> {
                    callbackContext.success(rm.getBiometryDetection().toJson())
                }
                RaspDetection.PLAY_PROTECT_ENABLED -> {
                    callbackContext.success(if (rm.isPlayProtectEnabled() == true) 1 else 0)
                }
                RaspDetection.DEVELOPER_OPTIONS -> {
                    callbackContext.success(if (rm.isDeveloperOptionsEnabled()) 1 else 0)
                }

                else -> {
                    callbackContext.error(Error.RASP_UNKNOWN_DETECTION.name)
                }
            }
        })
    }

    private fun setRaspCallback(callbackContext: CallbackContext) {

        fun prepareObject(type: RaspCallbackType): JSONObject {
            return JSONObject().also { it.put("type", type.name) }
        }

        fun resolve(jsonObject: JSONObject) {
            cordova.threadPool.execute(Runnable {
                raspCallbackContext?.sendPluginResult(PluginResult(PluginResult.Status.OK, jsonObject).also { it.keepCallback = true })
            })
        }

        clearRaspCallback(null)
        raspCallbackContext = callbackContext
        raspObserver = object : RaspObserver {

            private val payloadProperty = "payload"

            override fun onDebuggerDetected(debuggerDetected: Boolean) {
                val o = prepareObject(RaspCallbackType.DEBUGGER).also { it.put(payloadProperty, debuggerDetected) }
                resolve(o)
            }

            override fun onEmulatorDetected(emulatorDetection: EmulatorDetection) {
                val o = prepareObject(RaspCallbackType.EMULATOR).also { it.put(payloadProperty, emulatorDetection.toJson()) }
                resolve(o)
            }

            override fun onRepackagingDetected(repackagingResult: RepackagingResult) {
                val o = prepareObject(RaspCallbackType.REPACKAGING).also { it.put(payloadProperty, repackagingResult.name) }
                resolve(o)
            }

            override fun onRootDetected(rootDetection: RootDetection) {
                val o = prepareObject(RaspCallbackType.ROOT).also { it.put(payloadProperty, rootDetection.toJson()) }
                resolve(o)
            }

            override fun onScreenSharingDetected(screenSharingDetection: ScreenSharingDetection) {
                val o = prepareObject(RaspCallbackType.SCREEN_SHARING).also { it.put(payloadProperty, screenSharingDetection.toJson()) }
                resolve(o)
            }

            override fun onScreenReaderDetected(screenReaderDetection: ScreenReaderDetection) {
                val o = prepareObject(RaspCallbackType.SCREEN_READER).also { it.put(payloadProperty, screenReaderDetection.toJson()) }
                resolve(o)
            }

            override fun onTapjackingDetected(tapjackingDetection: TapjackingDetection) {
                val o = prepareObject(RaspCallbackType.TAPJACKING).also { it.put(payloadProperty, tapjackingDetection.toJson()) }
                resolve(o)
            }

            override fun onHttpProxyDetected(httpProxyDetection: HttpProxyDetection) {
                val o = prepareObject(RaspCallbackType.HTTP_PROXY).also { it.put(payloadProperty, httpProxyDetection.toJson()) }
                resolve(o)
            }

            override fun onVpnDetected(vpnEnabled: Boolean) {
                val o = prepareObject(RaspCallbackType.VPN).also { it.put(payloadProperty, vpnEnabled) }
                resolve(o)
            }

            override fun onAdbStatusDetected(adbStatus: Boolean) {
                val o = prepareObject(RaspCallbackType.ADB_STATUS).also { it.put(payloadProperty, adbStatus) }
                resolve(o)
            }

            override fun onActiveCallDetected(activeCallDetection: ActiveCallDetection) {
                val o = prepareObject(RaspCallbackType.ACTIVE_CALL).also { it.put(payloadProperty, activeCallDetection.toJson()) }
                resolve(o)
            }

            override fun onAppPresenceChanged(appPresenceDetection: AppPresenceDetection) {
                val o = prepareObject(RaspCallbackType.APP_PRESENCE).also { it.put(payloadProperty, appPresenceDetection.toJson()) }
                resolve(o)
            }

        }.also { appProtection!!.getRaspManager().registerRaspObserver(it) }
    }

    private fun clearRaspCallback(callbackContext: CallbackContext?) {
        val result = PluginResult(PluginResult.Status.NO_RESULT, "Rasp Callback Cleared")
        result.keepCallback = false
        raspCallbackContext?.sendPluginResult(result)
        raspObserver?.let { appProtection!!.getRaspManager().unregisterRaspObserver(it) }
        raspObserver = null
        callbackContext?.success()
    }
}

data class JsMalwarelyticsConfig(val clientId: String?,
                                 val deviceId: String?,
                                 val androidConfig: JsAndroidConfig?)

data class JsAndroidConfig(val languageCode: String?,
                           val antivirusConfig: JsAntivirusConfig?,
                           val raspConfig: JsRaspConfig?,
                           val customerGroupingConfig: JsCustomerGroupingConfig?,
                           val fingerprint: JsFingerprintType?)

data class JsCustomerGroupingConfig(val sourcePackageName: String?,
                                    val appPackageName: String?,
                                    val audienceGroupId: String?)

enum class JsFingerprintType {
    NONE,
    BASIC,
    SAFE,
    FULL;

    fun toFingerprintType(): FingerprintType {
        return when (this) {
            NONE -> FingerprintType.NONE
            BASIC -> FingerprintType.BASIC
            SAFE -> FingerprintType.SAFE
            FULL -> FingerprintType.FULL
        }
    }
}

data class JsAntivirusConfig(val enableSilentMode: Boolean?,
                             val onlineCheckIntervalHours: Int?,
                             val updateOnInitialize: Boolean?)

data class JsRaspConfig(val emulator: JsRaspDetectionConfig?,
                        val root: JsRaspRootDetectionConfig?,
                        val debugger: JsRaspDebuggerDetectionConfig?,
                        val repackage: JsRaspRepackageDetectionConfig?,
                        val screenSharing: JsRaspDetectionConfig?,
                        val screenshot: JsRaspBlockConfig?,
                        val screenReader: JsRaspScreenReaderBlockConfig?,
                        val processName: JsRaspProcessNameConfig?,
                        val tapjacking: JsRaspTapjackingBlockConfig?,
                        val httpProxy: JsRaspDetectionConfig?,
                        val vpn: JsRaspDetectionConfig?,
                        val adb: JsRaspAdbDetectionConfig?,
                        val activeCall: JsRaspSimpleDetectionConfig?,
                        val appPresence: JsRaspAppPresenceDetectionConfig?)

data class JsRaspDetectionConfig(val action: JsRaspDetectionAction,
                                 val exitUrl: String?) {
    fun toDetectionConfig(): DetectionConfig {
        return action.toDetectionConfig(exitUrl)
    }
}
data class JsRaspRootDetectionConfig(val action: JsRaspDetectionAction,
                                     val exitUrl: String?,
                                     val exitOnRootMinConfidence: Float?) {
    fun toRootDetectionConfig(): RootDetectionConfig {
        return when (action) {
            JsRaspDetectionAction.NO_ACTION -> RootDetectionConfig.NoAction
            JsRaspDetectionAction.NOTIFY -> RootDetectionConfig.Notify
            JsRaspDetectionAction.EXIT -> {
                if (exitOnRootMinConfidence != null) {
                    RootDetectionConfig.Exit(exitUrl, exitOnRootMinConfidence)
                } else {
                    RootDetectionConfig.Exit(exitUrl)
                }
            }
        }
    }
}
data class JsRaspDebuggerDetectionConfig(val action: JsRaspDetectionAction,
                                         val exitUrl: String?,
                                         val debuggerTypes: Array<JsDebuggerType>?) {
    fun toDebuggerDetectionConfig(): DebuggerDetectionConfig {
        val builder = DebuggerDetectionConfig.Builder()
            .action(action.toDetectionConfig(exitUrl))
        debuggerTypes?.let { types ->
            builder.debuggerTypes(types.map { it.toDebuggerType() })
        }
        return builder.build()
    }
}
data class JsRaspRepackageDetectionConfig(val action: JsRaspDetectionAction,
                                          val exitUrl: String?,
                                          val signatureHash: Array<String>) {
    fun toRepackageDetectionConfig(): RepackageDetectionConfig {
        return RepackageDetectionConfig.Builder()
            .action(action.toDetectionConfig(exitUrl))
            .signatureHash(signatureHash.toList())
            .build()
    }
}
/** Configuration of the basic block behavior */
data class JsRaspBlockConfig(val action: JsRaspBlockAction) {
    fun toBlockConfig(): BlockConfig {
        return action.toBlockConfig()
    }
}
data class JsRaspScreenReaderBlockConfig(val action: JsRaspBlockAction,
                                         val allowedScreenReaders: Array<JsApk>?) {
    fun toScreenReaderBlockConfig(): ScreenReaderBlockConfig {
        val builder = ScreenReaderBlockConfig.Builder()
            .action(action.toBlockConfig())
        allowedScreenReaders?.let { readers -> 
            builder.allowedScreenReaders(readers.map { it.toApkAllowList() })
        }
        return builder.build()
    }
}
data class JsRaspProcessNameConfig(val action: JsRaspProcessNameAction,
                                   val customProcessName: String?) {
    fun toProcessNameConfig(): ProcessNameConfig {
        return when (action) {
            JsRaspProcessNameAction.NO_ACTION -> ProcessNameConfig.NoAction
            JsRaspProcessNameAction.USE_STEALTHY -> ProcessNameConfig.UseStealthy(customProcessName)
        }
    }
}
data class JsRaspTapjackingBlockConfig(val action: JsRaspBlockAction,
                                       val blockTapjackingSensitivity: JSThreatIndex?,
                                       val ignoreTapjackingSystemApps: Boolean?,
                                       val allowedTapjackingApps: Array<JsApk>?) {
    fun toTapjackingBlockConfig(): TapjackingBlockConfig {
        val builder = TapjackingBlockConfig.Builder()
            .action(action.toBlockConfig())
        blockTapjackingSensitivity?.let {
            builder.blockTapjackingSensitivity(it.toThreatIndex())
        }
        ignoreTapjackingSystemApps?.let { 
            builder.ignoreTapjackingSystemApps(it) 
        }
        allowedTapjackingApps?.let { apps ->
            builder.allowedTapjackingApps(apps.map { it.toApkAllowList() })
        }
        return builder.build()
    }
}
data class JsRaspAdbDetectionConfig(val action: JsRaspAdbDetectionAction,
                                    val exitUrl: String?) {
    fun toAdbDetectionConfig(): AdbDetectionConfig {
        return when (action) {
            JsRaspAdbDetectionAction.NOTIFY -> AdbDetectionConfig.Notify
            JsRaspAdbDetectionAction.EXIT -> AdbDetectionConfig.Exit(exitUrl)
        }
    }
}
data class JsRaspSimpleDetectionConfig(val action: JsRaspSimpleDetectionAction) {
    fun toSimpleDetectinConfig(): SimpleDetectionConfig {
        return action.toSimpleDetectinConfig()
    }
}
data class JsRaspAppPresenceDetectionConfig(val action: JsRaspDetectionAction,
                                            val exitUrl: String?,
                                            val remoteDesktopApps: Array<JsRaspNamedApkItem>?) {
    fun toAppPresenceDetectionConfig(): AppPresenceDetectionConfig {
        val builder = AppPresenceDetectionConfig.Builder()
            .action(action.toDetectionConfig(exitUrl))
        remoteDesktopApps?.let { apps ->
            builder.remoteDesktopApps(apps.map { it.toNamedApkItem() })
        }
        return builder.build()
    }
}

data class JsRaspNamedApkItem(val displayName: String,
                              val packageName: String,
                              val signatureHash: String?) {
    fun toNamedApkItem(): NamedApkItem {
        return NamedApkItem(displayName, packageName, signatureHash)
    }
}

enum class JsRaspDetectionAction {
    NO_ACTION,
    NOTIFY,
    EXIT;

    fun toDetectionConfig(exitUrl: String?): DetectionConfig {
        return when (this) {
            NO_ACTION -> DetectionConfig.NoAction
            NOTIFY -> DetectionConfig.Notify
            EXIT -> DetectionConfig.Exit(exitUrl)
        }
    }
}
enum class JsRaspBlockAction {
    NO_ACTION,
    BLOCK;

    fun toBlockConfig(): BlockConfig {
        return when (this) {
            NO_ACTION -> BlockConfig.NoAction
            BLOCK -> BlockConfig.Block
        }
    }
}
enum class JsRaspProcessNameAction {
    NO_ACTION,
    USE_STEALTHY
}
enum class JsRaspAdbDetectionAction {
    NOTIFY,
    EXIT
}
enum class JsRaspSimpleDetectionAction {
    NO_ACTION,
    NOTIFY;

    fun toSimpleDetectinConfig(): SimpleDetectionConfig {
        return when (this) {
            NO_ACTION -> SimpleDetectionConfig.NoAction
            NOTIFY -> SimpleDetectionConfig.Notify
        }
    }
}


enum class JSThreatIndex {
    @SerializedName("UNKNOWN")
    UNKNOWN,
    @SerializedName("SAFE")
    SAFE,
    @SerializedName("POTENTIALLY_UNWANTED_APP")
    POTENTIALLY_UNWANTED_APP,
    @SerializedName("DANGEROUS")
    DANGEROUS,
    @SerializedName("HIGHLY_DANGEROUS")
    HIGHLY_DANGEROUS,
    @SerializedName("MALWARE")
    MALWARE;

    fun toThreatIndex(): ThreatIndex {
        return when(this) {
            UNKNOWN -> ThreatIndex.UNKNOWN
            SAFE -> ThreatIndex.SAFE
            POTENTIALLY_UNWANTED_APP -> ThreatIndex.POTENTIALLY_UNWANTED_APP
            DANGEROUS -> ThreatIndex.DANGEROUS
            HIGHLY_DANGEROUS -> ThreatIndex.HIGHLY_DANGEROUS
            MALWARE -> ThreatIndex.MALWARE
        }
    }
}

enum class JsDebuggerType {
    JAVA,
    NATIVE;

    fun toDebuggerType(): DebuggerType {
        return when (this) {
            JAVA -> DebuggerType.JAVA
            NATIVE -> DebuggerType.NATIVE
        }
    }
}

data class JsApk(val packageName: String, val signatureHash: String? = null) {
    fun toApkAllowList() = RaspConfig.ApkAllowlistItem(packageName, signatureHash)
}


private fun RootDetection.toJson(): JSONObject {
    val o = JSONObject()
    o.put("isRooted", isRooted)
    o.put("rootDetectionConfidence", rootDetectionConfidence)
    o.put("isRootCloaked", isRootCloaked)
    o.put("rootCloakDetectionConfidence", rootCloakDetectionConfidence)
    o.put("rootDetectionProofs", JSONArray(rootDetectionProofs.map { it.name }))
    return o
}

private fun EmulatorDetection.toJson(): JSONObject {
    val o = JSONObject()
    o.put("isEmulator", isEmulator)
    detectedEmulatorType?.let { o.put("detectedEmulatorType", it) }
    o.put("emulatorDetectionProofs", JSONArray(emulatorDetectionProofs.map { it.name }))
    return o
}

private fun DebuggerDetection.toJson(): JSONObject {
    val o = JSONObject()
    o.put("isDebuggerAttached", isDebuggerAttached)
    o.put("isWaitingForDebugger", isWaitingForDebugger)
    o.put("debuggerType", JSONArray(debbuggerType.map { it.name }))
    return o
}

private fun ScreenSharingDetection.toJson(): JSONObject {
    val o = JSONObject()
    o.put("isScreenShared", isScreenShared)
    o.put("numberOfDisplays", numberOfDisplays)
    o.put("transientData", transientData.toJson())
    o.put("isProblematic", isProblematic)
    o.put("isTransientChange", isTransientChange)
    return o
}

private fun ScreenSharingDetection.TransientScreenSharingData.toJson(): JSONObject {
    val o = JSONObject()
    o.put("displayAdded", displayAdded)
    o.put("displayRemoved", displayRemoved)
    return o
}

private fun TapjackingDetection.toJson(): JSONObject {
    val o = JSONObject()
    o.put("isTapjackingBlocked", isTapjackingBlocked)
    o.put("tapjackingCapableApps", JSONArray(tapjackingCapableApps))
    return o
}

private fun HttpProxyDetection.toJson(): JSONObject {
    val o = JSONObject()
    o.put("isHttpProxyEnabled", isHttpProxyEnabled)
    o.put("isUsingAutoConfig", isUsingAutoConfig())
    o.put("host", host)
    o.put("port", port)
    o.put("exclusionList", exclusionList)
    o.put("pacFileUrl", pacFileUrl?.toString())
    return o
}

private fun ActiveCallDetection.toJson(): JSONObject {
    val o = JSONObject()
    o.put("callState", callState.name)
    return o
}

private fun AppPresenceDetection.toJson(): JSONObject {
    val o = JSONObject()
    o.put("remoteDesktopApps", JSONArray(remoteDesktopApps.map { it.toJson() }))
    return o
}

private fun NamedApkItemInfo.toJson(): JSONObject {
    val o = JSONObject()
    o.put("displayName", displayName)
    o.put("appName", appName)
    o.put("packageName", packageName)
    o.put("versionName", versionName)
    o.put("versionCode", versionCode)
    o.put("signatureHash", signatureHash)
    return o
}

private fun ScreenReaderDetection.toJson(): JSONObject {
    val o = JSONObject()
    o.put("isNotAllowedScreenReaderEnabled", isNotAllowedScreenReaderEnabled)
    o.put("notAllowedScreenReaders", JSONArray(notAllowedScreenReaders))
    o.put("enabledScreenReaders", JSONArray(enabledScreenReaders))
    o.put("installedScreenReaders", JSONArray(installedScreenReaders))
    return o
}

private fun BiometryDetection.toJson(): JSONObject {
    val o = JSONObject()
    o.put("biometricStatus", biometricStatus.name)
    o.put("androidxLibStatus", androidxLibStatus)
    return o
}

private fun ApkThreat.toJson(): JSONObject {
    val o = JSONObject()
    o.put("evaluatedThreatIndex", evaluatedThreatIndex.name)
    o.put("malwareDetectionName", malwareDetectionName ?: JSONObject.NULL)
    o.put("mitigations", JSONArray(mitigations.map { it.name }))
    o.put("packageName", packageName)
    o.put("reasons", JSONArray(reasons.map { it.name }))
    o.put("suggestedThreatIndex", suggestedThreatIndex.name)
    o.put("threatIndex", threatIndex.name)
    o.put("threatInstaller", threatInstaller?.name ?: JSONObject.NULL)
    o.put("flags", JSONArray(flags.map { it.toJson() }))
    return o
}

private fun MalwareFlag.toJson(): JSONObject {
    val o = JSONObject()
    o.put("name", name)
    o.put("type", type.name)
    return o
}

private fun UpdateInfo.toJson(): JSONObject {
    val o = JSONObject()
    val s = successfulUpdates.toList().fold(JSONObject()) { acc, it -> 
        acc.put(it.first.name, it.second) 
    }
    o.put("successfulUpdates", s)
    val f = failedUpdates.toList().fold(JSONObject()) { acc, it -> 
        acc.put(it.first.name, it.second)
    }
    o.put("failedUpdates", f)
    return o
}

private fun ObservedUpdateInfo.toJson():  JSONObject {
    val o = JSONObject()
    o.put("updateResult", updateResult.name)
    o.put("updateType", updateType.name)
    o.put("checkedApps", JSONArray(checkedApps))
    o.put("updatedApps", JSONArray(updatedApps))
    o.put("failureReason", failureReason)
    return o
}