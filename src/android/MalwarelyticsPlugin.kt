//
// Copyright 2023 Wultra s.r.o.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions
// and limitations under the License.
//

package com.wultra.android.cordova.malwarelytics.plugin

import android.content.pm.PackageManager
import android.graphics.Bitmap
import android.graphics.drawable.BitmapDrawable
import android.util.Base64.encodeToString
import com.google.gson.Gson
import com.google.gson.annotations.SerializedName
import com.wultra.android.antimalware.AntivirusConfig
import com.wultra.android.antimalware.ApkThreat
import com.wultra.android.antimalware.MalwareFlag
import com.wultra.android.antimalware.ThreatIndex
import com.wultra.android.appprotection.AppProtection
import com.wultra.android.appprotection.AppProtectionConfig
import com.wultra.android.rasp.*
import org.apache.cordova.CallbackContext
import org.apache.cordova.CordovaPlugin
import org.apache.cordova.PluginResult
import org.json.JSONArray
import org.json.JSONException
import org.json.JSONObject
import java.io.ByteArrayOutputStream
import java.lang.Exception
import java.util.*

class MalwarelyticsPlugin : CordovaPlugin() {

    private enum class Error {
        PLUGIN_UNKNOWN_ACTION,
        PLUGIN_ALREADY_INITIALIZED,
        PLUGIN_NOT_INITIALIZED,

        MISSING_ARGUMENTS,

        INITIALIZE_MISSING_CREDENTIALS,
        INITIALIZE_WRONG_CONFIG,
        INITIALIZE_WRONG_ENVIRONMENT,

        TRIGGER_SMART_PROTECTION_UPDATE_FAILED,
        TRIGGER_SMART_PROTECTION_FAILED,

        UTILS_LANG_CHANGE_FAILED,

        THREAT_LIST_FAILED,

        APK_INFO_NOT_AVAILABLE,

        RASP_UNKNOWN_DETECTION
    }

    private enum class RaspDetection {
        /* root */
        ROOT_DETECTION,
        IS_ROOTED,

        /* emulator */
        IS_EMULATOR,
        EMULATOR_INFO,
        
        /* debugger */
        IS_DEBUGGER,
        DEBUGGER_INFO,

        /* repackaging */
        REPACKAGE_INFO,

        /* screen sharing */
        IS_SCREEN_SHARED,
        SCREEN_SHARED_INFO,

        /* screen lock */
        SCREEN_LOCK_ENABLED,

        /* play protect */
        PLAY_PROTECT_ENABLED,

        /* screen reader */
        NOT_ALLOWED_SCREEN_READER_ENABLED,

        /* tapjacking */
        IS_BAD_TAPJACKING_CAPABLE_APP_PRESENT,
        TAPJACKING_INFO,

        /* http proxy */
        HTTP_PROXY_INFO,
        IS_HTTP_PROXY,

        /* VPN */
        IS_VPN,

        /* developer options */
        DEVELOPER_OPTIONS,

        /* ADB status */
        ADB_STATUS,

        /* biometry */
        BIOMETRY,

        /* active call */
        IS_ACTIVE_CALL,
        ACTIVE_CALL_INFO
    }

    private enum class RaspCallbackType {
        DEBUGGER,
        EMULATOR,
        REPACKAGING,
        ROOT,
        SCREEN_SHARING,
        TAPJACKING,
        HTTP_PROXY,
        VPN,
        ADB_STATUS,
        ACTIVE_CALL
    }

    private var appProtection: AppProtection? = null

    private var raspObserver: RaspObserver? = null
    private var raspCallbackContext: CallbackContext? = null

    @Throws(JSONException::class)
    override fun execute(action: String, args: JSONArray, callbackContext: CallbackContext): Boolean {
        
        if (action == "initialize") {
            val obj = args.getString(0)
            return try {
                val config = Gson().fromJson(obj, JsMalwarelyticsConfig::class.java)
                this.initialize(config, callbackContext)
                true
            } catch(e: Throwable) {
                callbackContext.error(Error.INITIALIZE_WRONG_CONFIG.name)
                false
            }
        }

        if (action == "isInitialized") {
            this.isInitialized(callbackContext)
            return true
        }

        if (action == "triggerSmartProtection") {
            val performOnlineUpdate: Boolean = if (args.isNull(0)) {
                true
            } else {
                args.getBoolean(0)
            }
            this.triggerSmartProtection(performOnlineUpdate, callbackContext)
            return true
        }

        if (action == "setClientId") {
            val clientId: String? = if(args.isNull(0)) {
                null
            } else {
                args.getString(0)
            }
            this.setClientId(clientId, callbackContext)
            return true
        }

        if (action == "setDeviceId") {
            val deviceId: String? = if(args.isNull(0)) {
                null
            } else {
                args.getString(0)
            }
            this.setDeviceId(deviceId, callbackContext)
            return true
        }

        if (action == "changeAppLanguage") {
            val lang: String? = if(args.isNull(0)) {
                null
            } else {
                args.getString(0)
            }
            setLanguage(lang, callbackContext)
            return true
        }

        if (action == "getInitializationResult") {
            getInitialzationResult(callbackContext)
            return true
        }

        if (action == "getThreatList") {
            getThreatList(callbackContext)
            return true
        }

        if (action == "getApkInfo") {
            val packageName = args.optString(0)
            return if (packageName != null) {
                getApkInfo(packageName, callbackContext)
                true
            } else {
                callbackContext.error(Error.MISSING_ARGUMENTS.name)
                false
            }
        }

        if (action == "raspInfo") {
            val info = args.optString(0)
            return if (info != null) {
                getRaspDetection(RaspDetection.valueOf(info), callbackContext)
                true
            } else {
                callbackContext.error(Error.MISSING_ARGUMENTS.name)
                false
            }
        }

        if (action == "setRaspCallback") {
            setRaspCallback(callbackContext)
            return true
        }

        if (action == "clearRaspCallback") {
            clearRaspCallback(callbackContext)
            return true
        }

        callbackContext.error(Error.PLUGIN_UNKNOWN_ACTION.name)

        return false
    }

    private fun isInitialized(callbackContext: CallbackContext? = null): Boolean {
        val result = this.appProtection?.isInitialized() ?: false
        callbackContext?.success(if (result) 1 else 0)
        return result
    }

    private fun initialize(config: JsMalwarelyticsConfig, callbackContext: CallbackContext) {

        cordova.threadPool.execute(Runnable {

            if (isInitialized()) {
                callbackContext.error(Error.PLUGIN_ALREADY_INITIALIZED.name)
                return@Runnable
            }

            val username = MalwarelyticsConfig.USER_NAME
            val password = MalwarelyticsConfig.PASSWORD

            if (password == "" || username == "") {
                callbackContext.error(Error.INITIALIZE_MISSING_CREDENTIALS.name)
                return@Runnable
            }

            val context = cordova.activity

            val cg = AppProtectionConfig.CustomerGroupingConfig.Builder()
            config.androidConfig?.customerGroupingConfig?.sourcePackageName?.let { cg.sourcePackageName(it) }
            config.androidConfig?.customerGroupingConfig?.appPackageName?.let { cg.appPackageName(it) }
            config.androidConfig?.customerGroupingConfig?.audienceGroupId?.let { cg.audienceGroupId(it) }

            val spb = AntivirusConfig.SmartProtectionConfig.Builder()
                .silentModeEnabled(config.androidConfig?.antivirusConfig?.enableSilentMode ?: true)
                .performInitialFirstUpdate(config.androidConfig?.antivirusConfig?.updateOnInitialize ?: true)
                .smartProtectionIntervalHours(config.androidConfig?.antivirusConfig?.onlineCheckIntervalHours ?: 48)

            val rb = RaspConfig.Builder()
            config.androidConfig?.raspConfig?.let {
                it.emulator?.applyToRaspConfig(rb, 
                                                RaspConfig.Builder::checkEmulator, 
                                                RaspConfig.Builder::exitOnEmulator, 
                                                RaspConfig.Builder::exitOnEmulatorUrl)
                it.root?.applyToRaspConfig(rb)   
                it.debugger?.applyToRaspConfig(rb, 
                                                RaspConfig.Builder::checkDebugger, 
                                                RaspConfig.Builder::exitOnDebugger, 
                                                RaspConfig.Builder::exitOnDebuggerUrl)
                it.repackage?.applyToRaspConfig(rb)   
                it.screenSharing?.applyToRaspConfig(rb, 
                                                RaspConfig.Builder::checkScreenSharing, 
                                                RaspConfig.Builder::exitOnScreenSharing, 
                                                RaspConfig.Builder::exitOnScreenSharingUrl)
                it.screenshot?.applyToRaspConfig(rb,
                                                RaspConfig.Builder::blockScreenshots)   
                it.screenReader?.applyToRaspConfig(rb)   
                it.processName?.applyToRaspConfig(rb)   
                it.tapjacking?.applyToRaspConfig(rb)   
                it.httpProxy?.applyToRaspConfig(rb, 
                                                RaspConfig.Builder::checkHttpProxy, 
                                                RaspConfig.Builder::exitOnHttpProxy, 
                                                RaspConfig.Builder::exitOnHttpProxyUrl)
                it.vpn?.applyToRaspConfig(rb, 
                                                RaspConfig.Builder::checkVpn, 
                                                RaspConfig.Builder::exitOnVpn, 
                                                RaspConfig.Builder::exitOnVpnUrl)
                it.adb?.applyToRaspConfig(rb)   
                it.activeCall?.applyToRaspConfig(rb,
                                                RaspConfig.Builder::checkActiveCall)   
            }

            val tmBuilder = AntivirusConfig.ThreatMitigationUIConfig.Builder()
            MalwarelyticsConfig.THEME?.let { tmBuilder.screenTheme(it) }
            MalwarelyticsConfig.NOTIFICATION_ICON?.let { tmBuilder.notificationSmallIcon(it) }
            MalwarelyticsConfig.SETTINGS_ICON?.let { tmBuilder.screenSettingsIcon(it) }
            MalwarelyticsConfig.DELETE_ICON?.let { tmBuilder.screenDeleteIcon(it) }
            config.androidConfig?.languageCode?.let { tmBuilder.customLocalization(it) }

            val avConfigBuilder = AntivirusConfig.Builder().smartProtectionConfig(spb.build())
            avConfigBuilder.threatMitigationUIConfig(tmBuilder.build())

            val builder = AppProtectionConfig.Builder(context)
                .antivirusConfig(avConfigBuilder.build())
                .raspConfig(rb.build())
                .customerGroupingConfig(cg.build())
                .apiUsername(username)
                .apiPassword(password)

            when (MalwarelyticsConfig.ENVIRONMENT) {
                "PRODUCTION" -> builder.environment(AppProtectionConfig.EnvironmentConfiguration.PRODUCTION_ENVIRONMENT)
                "TEST" -> builder.environment(AppProtectionConfig.EnvironmentConfiguration.TEST_ENVIRONMENT)
                else -> {
                    callbackContext.error(Error.INITIALIZE_WRONG_ENVIRONMENT.name)
                    return@Runnable
                }
            }

            MalwarelyticsConfig.API_PUBLIC_KEY?.let { builder.apiSignaturePublicKey(it) }
            config.clientId?.let { builder.clientAppUserId(it) }
            config.deviceId?.let { builder.clientAppDeviceId(it) }

            val appProtection = AppProtection.getInstance()
            this@MalwarelyticsPlugin.appProtection = appProtection
            appProtection.initializeAsync(builder.build(), object : AppProtection.InitializationObserver {
                override fun onInitialized(initializationResult: AppProtection.InitializationResult) {
                    callbackContext.success(initializationResult.name)
                }
            })
        })
    }

    private fun getInitialzationResult(callbackContext: CallbackContext) {
        val result = this.appProtection!!.getInitializationResult()
        if (result == null) {
            callbackContext.error(Error.PLUGIN_NOT_INITIALIZED.name)
        } else {
            callbackContext.success(result.name)
        }
    }

    private fun setClientId(clientId: String?, callbackContext: CallbackContext) {
        if (!this.isInitialized()) {
            callbackContext.error(Error.PLUGIN_NOT_INITIALIZED.name)
            return
        }

        this.appProtection!!.updateClientAppUserId(clientId)
        callbackContext.success()
    }

    private fun setDeviceId(deviceId: String?, callbackContext: CallbackContext) {

        if (!this.isInitialized()) {
            callbackContext.error(Error.PLUGIN_NOT_INITIALIZED.name)
            return
        }

        this.appProtection!!.updateClientAppDeviceId(deviceId)
        callbackContext.success()
    }

    private fun setLanguage(language: String?, callbackContext: CallbackContext) {
        if (!this.isInitialized()) {
            callbackContext.error(Error.PLUGIN_NOT_INITIALIZED.name)
            return
        }
        if (language != null) {
            this.appProtection!!.getAntivirus().getSmartProtectionManager().setCustomLocalization(language)
            callbackContext.success()
        } else {
            callbackContext.error(Error.UTILS_LANG_CHANGE_FAILED.name)
        }
    }

    private fun triggerSmartProtection(performOnlineUpdate: Boolean, callbackContext: CallbackContext) {
        cordova.threadPool.execute(Runnable {
            if (!isInitialized()) {
                callbackContext.error(Error.PLUGIN_NOT_INITIALIZED.name)
            } else {
                val updateResult = appProtection!!.getAntivirus().getSmartProtectionManager().performSingleSmartProtectionUpdate(performOnlineUpdate)
                val o = JSONObject()
                o.put("uiDisplayed", updateResult.uiDisplayed)
                o.put("onlineUpdateSucceeded", updateResult.onlineUpdateSucceeded)
                o.put("evaluationSucceeded", updateResult.evaluationSucceeded)
                callbackContext.success(o)
            }
        })
    }

    private fun getThreatList(callbackContext: CallbackContext) {
        cordova.threadPool.execute(Runnable {
            if (!isInitialized()) {
                callbackContext.error(Error.PLUGIN_NOT_INITIALIZED.name)
            } else {
                try {
                    val list = appProtection!!.getAntivirus().evaluateThreats()
                    val items = JSONArray(list.map { t -> t.toJson() })
                    val response = JSONObject()
                    response.put("items", items)
                    callbackContext.success(response)
                } catch (e: Exception) {
                    callbackContext.error(Error.THREAT_LIST_FAILED.name)
                }
            }
        })
    }

    private fun getApkInfo(packageName: String, callbackContext: CallbackContext) {
        cordova.threadPool.execute(Runnable {
            if (!isInitialized()) {
                callbackContext.error(Error.PLUGIN_NOT_INITIALIZED.name)
            } else {
                try {
                    val pm = cordova.activity.packageManager
                    @Suppress("DEPRECATION") 
                    val label = pm.getApplicationLabel(pm.getApplicationInfo(packageName, PackageManager.GET_META_DATA))
                    val icon = (pm.getApplicationIcon(packageName) as? BitmapDrawable)?.let { bd ->
                        val stream = ByteArrayOutputStream()
                        bd.bitmap.compress(Bitmap.CompressFormat.PNG, 100, stream)
                        return@let encodeToString(stream.toByteArray(), android.util.Base64.DEFAULT)
                    }
                    val o = JSONObject()
                    o.put("label", label)
                    o.put("icon", icon ?: JSONObject.NULL)
                    callbackContext.success(o)
                } catch (e: Exception) {
                    callbackContext.error(Error.APK_INFO_NOT_AVAILABLE.name)
                }
            }
        })
    }

    private fun getRaspDetection(detection: RaspDetection, callbackContext: CallbackContext) {
        cordova.threadPool.execute(Runnable {

            if (!isInitialized()) {
                callbackContext.error(Error.PLUGIN_NOT_INITIALIZED.name)
                return@Runnable
            }

            val rm = appProtection!!.getRaspManager()
            when (detection) {
                RaspDetection.ROOT_DETECTION -> {
                    callbackContext.success(rm.getRootDetection().toJson())
                }
                RaspDetection.IS_ROOTED -> {
                    callbackContext.success(if (rm.isDeviceRooted()) 1 else 0)
                }
                RaspDetection.EMULATOR_INFO -> {
                    callbackContext.success(rm.getEmulatorDetection().toJson())
                }
                RaspDetection.IS_EMULATOR -> {
                    callbackContext.success(if (rm.isDeviceEmulator()) 1 else 0)
                }
                RaspDetection.DEBUGGER_INFO -> {
                    callbackContext.success(rm.getDebuggerDetection().toJson())
                }
                RaspDetection.IS_DEBUGGER -> {
                    callbackContext.success(if (rm.isDebuggerAttached()) 1 else 0)
                }
                RaspDetection.REPACKAGE_INFO -> {
                    callbackContext.success(rm.isAppRepackaged().name)
                }
                RaspDetection.SCREEN_SHARED_INFO -> {
                    callbackContext.success(rm.getScreenSharingDetection().toJson())
                }
                RaspDetection.IS_SCREEN_SHARED -> {
                    callbackContext.success(if (rm.isScreenShared()) 1 else 0)
                }
                RaspDetection.SCREEN_LOCK_ENABLED -> {
                    callbackContext.success(if (rm.isDeviceUsingScreenLock()) 1 else 0)
                }
                RaspDetection.PLAY_PROTECT_ENABLED -> {
                    callbackContext.success(if (rm.isPlayProtectEnabled() == true) 1 else 0)
                }
                RaspDetection.NOT_ALLOWED_SCREEN_READER_ENABLED -> {
                    callbackContext.success(if (rm.isNotAllowedScreenReaderEnabled()) 1 else 0)
                }
                RaspDetection.IS_BAD_TAPJACKING_CAPABLE_APP_PRESENT -> {
                    callbackContext.success(if (rm.isBadTapjackingCapableAppPresent()) 1 else 0)
                }
                RaspDetection.TAPJACKING_INFO -> {
                    callbackContext.success(rm.getTapjackingDetection().toJson())
                }
                RaspDetection.HTTP_PROXY_INFO -> {
                    callbackContext.success(rm.getHttpProxyDetection().toJson())
                }
                RaspDetection.IS_HTTP_PROXY -> {
                    callbackContext.success(if (rm.isHttpProxyEnabled()) 1 else 0)
                }
                RaspDetection.IS_VPN -> {
                    callbackContext.success(if (rm.isVpnEnabled()) 1 else 0)
                }
                RaspDetection.DEVELOPER_OPTIONS -> {
                    callbackContext.success(if (rm.isDeveloperOptionsEnabled()) 1 else 0)
                }
                RaspDetection.ADB_STATUS -> {
                    callbackContext.success(if (rm.isAdbEnabled()) 1 else 0)
                }
                RaspDetection.BIOMETRY -> {
                    callbackContext.success(rm.getBiometryDetection().toJson())
                }
                RaspDetection.IS_ACTIVE_CALL -> {
                    callbackContext.success(if (rm.isCallActive()) 1 else 0)
                }
                RaspDetection.ACTIVE_CALL_INFO -> {
                    callbackContext.success(rm.getActiveCallDetection().toJson())
                }
                else -> {
                    callbackContext.error(Error.RASP_UNKNOWN_DETECTION.name)
                }
            }
        })
    }

    private fun setRaspCallback(callbackContext: CallbackContext) {

        fun prepareObject(type: RaspCallbackType): JSONObject {
            return JSONObject().also { it.put("type", type.name) }
        }

        fun resolve(jsonObject: JSONObject) {
            cordova.threadPool.execute(Runnable {
                raspCallbackContext?.sendPluginResult(PluginResult(PluginResult.Status.OK, jsonObject).also { it.keepCallback = true })
            })
        }

        clearRaspCallback(null)
        raspCallbackContext = callbackContext
        raspObserver = object : RaspObserver {

            private val payloadProperty = "payload"

            override fun onDebuggerDetected(debuggerDetected: Boolean) {
                val o = prepareObject(RaspCallbackType.DEBUGGER).also { it.put(payloadProperty, debuggerDetected) }
                resolve(o)
            }

            override fun onEmulatorDetected(emulatorDetection: EmulatorDetection) {
                val o = prepareObject(RaspCallbackType.EMULATOR).also { it.put(payloadProperty, emulatorDetection.toJson()) }
                resolve(o)
            }

            override fun onRepackagingDetected(repackagingResult: RepackagingResult) {
                val o = prepareObject(RaspCallbackType.REPACKAGING).also { it.put(payloadProperty, repackagingResult.name) }
                resolve(o)
            }

            override fun onRootDetected(rootDetection: RootDetection) {
                val o = prepareObject(RaspCallbackType.ROOT).also { it.put(payloadProperty, rootDetection.toJson()) }
                resolve(o)
            }

            override fun onScreenSharingDetected(screenSharingDetected: Boolean) {
                val o = prepareObject(RaspCallbackType.SCREEN_SHARING).also { it.put(payloadProperty, screenSharingDetected) }
                resolve(o)
            }

            override fun onTapjackingDetected(tapjackingDetection: TapjackingDetection) {
                val o = prepareObject(RaspCallbackType.TAPJACKING).also { it.put(payloadProperty, tapjackingDetection.toJson()) }
                resolve(o)
            }

            override fun onHttpProxyDetected(httpProxyDetection: HttpProxyDetection) {
                val o = prepareObject(RaspCallbackType.HTTP_PROXY).also { it.put(payloadProperty, httpProxyDetection.toJson()) }
                resolve(o)
            }

            override fun onVpnDetected(vpnEnabled: Boolean) {
                val o = prepareObject(RaspCallbackType.VPN).also { it.put(payloadProperty, vpnEnabled) }
                resolve(o)
            }

            override fun onAdbStatusDetected(adbStatus: Boolean) {
                val o = prepareObject(RaspCallbackType.ADB_STATUS).also { it.put(payloadProperty, adbStatus) }
                resolve(o)
            }

            override fun onActiveCallDetected(activeCallDetection: ActiveCallDetection) {
                val o = prepareObject(RaspCallbackType.ACTIVE_CALL).also { it.put(payloadProperty, activeCallDetection.toJson()) }
                resolve(o)
            }

        }.also { appProtection!!.getRaspManager().registerRaspObserver(it) }
    }

    private fun clearRaspCallback(callbackContext: CallbackContext?) {
        val result = PluginResult(PluginResult.Status.NO_RESULT, "Rasp Callback Cleared")
        result.keepCallback = false
        raspCallbackContext?.sendPluginResult(result)
        raspObserver?.let { appProtection!!.getRaspManager().unregisterRaspObserver(it) }
        raspObserver = null
        callbackContext?.success()
    }
}

data class JsMalwarelyticsConfig(val clientId: String?,
                                 val deviceId: String?,
                                 val androidConfig: JsAndroidConfig?)

data class JsAndroidConfig(val languageCode: String?,
                           val antivirusConfig: JsAntivirusConfig?,
                           val raspConfig: JsRaspConfig?,
                           val customerGroupingConfig: JsCustomerGroupingConfig?)

data class JsCustomerGroupingConfig(val sourcePackageName: String?,
                                    val appPackageName: String?,
                                    val audienceGroupId: String?)

data class JsAntivirusConfig(val enableSilentMode: Boolean?,
                             val onlineCheckIntervalHours: Int?,
                             val updateOnInitialize: Boolean?)

data class JsRaspConfig(val emulator: JsRaspDetectionConfig?,
                        val root: JsRaspRootDetectionConfig?,
                        val debugger: JsRaspDetectionConfig?,
                        val repackage: JsRaspRepackageDetectionConfig?,
                        val screenSharing: JsRaspDetectionConfig?,
                        val screenshot: JsRaspBlockConfig?,
                        val screenReader: JsRaspScreenReaderBlockConfig?,
                        val processName: JsRaspProcessNameConfig?,
                        val tapjacking: JsRaspTapjackingBlockConfig?,
                        val httpProxy: JsRaspDetectionConfig?,
                        val vpn: JsRaspDetectionConfig?,
                        val adb: JsRaspAdbDetectionConfig?,
                        val activeCall: JsRaspSimpleDetectionConfig?)

data class JsRaspDetectionConfig(val action: JsRaspDetectionAction,
                                 val exitUrl: String?) {
    fun applyToRaspConfig(rcb: RaspConfig.Builder,
                        checkMethod: RaspConfig.Builder.(Boolean) -> RaspConfig.Builder,
                        exitMethod: RaspConfig.Builder.(Boolean) -> RaspConfig.Builder,
                        exitUrlMethod: RaspConfig.Builder.(String) -> RaspConfig.Builder) {
        when (action) {
            JsRaspDetectionAction.NO_ACTION -> {
                    rcb.checkMethod(false)
                    rcb.exitMethod(false)
                }
            JsRaspDetectionAction.NOTIFY -> {
                    rcb.checkMethod(true)
                    rcb.exitMethod(false)
                }
            JsRaspDetectionAction.EXIT -> {
                    rcb.checkMethod(true)
                    rcb.exitMethod(true)
                    exitUrl?.let { url ->
                        rcb.exitUrlMethod(url)
                    }
                }
        }
    }
}
data class JsRaspRootDetectionConfig(val action: JsRaspDetectionAction,
                                     val exitUrl: String?,
                                     val exitOnRootMinConfidence: Float?) {
    fun applyToRaspConfig(rcb: RaspConfig.Builder) {
        when (action) {
            JsRaspDetectionAction.NO_ACTION -> {
                    rcb.checkRoot(false)
                    rcb.exitOnRoot(false)
                }
            JsRaspDetectionAction.NOTIFY -> {
                    rcb.checkRoot(true)
                    rcb.exitOnRoot(false)
                }
            JsRaspDetectionAction.EXIT -> {
                    rcb.checkRoot(true)
                    rcb.exitOnRoot(true)
                    exitUrl?.let { url ->
                        rcb.exitOnRootUrl(url)
                    }
                    exitOnRootMinConfidence?.let { confidence ->
                        rcb.exitOnRootMinConfidence(confidence)
                    }
                }
        }
    }
}
data class JsRaspRepackageDetectionConfig(val action: JsRaspDetectionAction,
                                          val exitUrl: String?,
                                          val signatureHash: Array<String>) {
    fun applyToRaspConfig(rcb: RaspConfig.Builder) {
        rcb.signatureHash(*signatureHash)
        when (action) {
            JsRaspDetectionAction.NO_ACTION -> {
                    rcb.checkRepackaging(false)
                    rcb.exitOnRepackaging(false)
                }
            JsRaspDetectionAction.NOTIFY -> {
                    rcb.checkRepackaging(true)
                    rcb.exitOnRepackaging(false)
                }
            JsRaspDetectionAction.EXIT -> {
                    rcb.checkRepackaging(true)
                    rcb.exitOnRepackaging(true)
                    exitUrl?.let { url ->
                        rcb.exitOnRepackagingUrl(url)
                    }
                }
        }
    }
}
/** Configuration of the basic block behavior */
data class JsRaspBlockConfig(val action: JsRaspBlockAction) {
    fun applyToRaspConfig(rcb: RaspConfig.Builder,
                            blockMethod: RaspConfig.Builder.(Boolean) -> RaspConfig.Builder
    ) {
        rcb.blockMethod(action == JsRaspBlockAction.BLOCK)
    }
}
data class JsRaspScreenReaderBlockConfig(val action: JsRaspBlockAction,
                                         val allowedScreenReaders: Array<JsApk>?) {
    fun applyToRaspConfig(rcb: RaspConfig.Builder) {
        rcb.blockScreenReaders(action == JsRaspBlockAction.BLOCK)
        allowedScreenReaders?.let { readers -> 
            rcb.allowedScreenReaders(readers.map { it.toApkAllowList() })
        }
    }
}
data class JsRaspProcessNameConfig(val action: JsRaspProcessNameAction,
                                   val customProcessName: String?) {
    fun applyToRaspConfig(rcb: RaspConfig.Builder) {
        rcb.useStealthyProcessName(action == JsRaspProcessNameAction.USE_STEALTHY)
        customProcessName?.let { name ->
            rcb.customProcessName(name)
        }
    }
}
data class JsRaspTapjackingBlockConfig(val action: JsRaspBlockAction,
                                       val blockTapjackingSensitivity: JSThreatIndex?,
                                       val ignoreTapjackingSystemApps: Boolean?,
                                       val allowedTapjackingApps: Array<JsApk>?) {
    fun applyToRaspConfig(rcb: RaspConfig.Builder) {
        rcb.blockTapjacking(action == JsRaspBlockAction.BLOCK)
        blockTapjackingSensitivity?.let {
            rcb.blockTapjackingSensitivity(it.toThreatIndex())
        }
        ignoreTapjackingSystemApps?.let { rcb.ignoreTapjackingSystemApps(it) }
        allowedTapjackingApps?.let { apps ->
            rcb.allowedTapjackingApps(apps.map { it.toApkAllowList() })
        }
    }
}
data class JsRaspAdbDetectionConfig(val action: JsRaspAdbDetectionAction,
                                    val exitUrl: String?) {
    fun applyToRaspConfig(rcb: RaspConfig.Builder) {
        rcb.exitOnAdbEnabled(action == JsRaspAdbDetectionAction.EXIT)
        exitUrl?.let { url ->
            rcb.exitOnAdbEnabledUrl(url)
        }
    }
}
data class JsRaspSimpleDetectionConfig(val action: JsRaspSimpleDetectionAction) {
    fun applyToRaspConfig(rcb: RaspConfig.Builder,
                          checkMethod: RaspConfig.Builder.(Boolean) -> RaspConfig.Builder
    ) {
        rcb.checkMethod(action == JsRaspSimpleDetectionAction.NOTIFY)
    }
}

enum class JsRaspDetectionAction {
    NO_ACTION,
    NOTIFY,
    EXIT
}
enum class JsRaspBlockAction {
    NO_ACTION,
    BLOCK
}
enum class JsRaspProcessNameAction {
    NO_ACTION,
    USE_STEALTHY
}
enum class JsRaspAdbDetectionAction {
    NOTIFY,
    EXIT
}
enum class JsRaspSimpleDetectionAction {
    NO_ACTION,
    NOTIFY
}


enum class JSThreatIndex {
    @SerializedName("UNKNOWN")
    UNKNOWN,
    @SerializedName("SAFE")
    SAFE,
    @SerializedName("POTENTIALLY_UNWANTED_APP")
    POTENTIALLY_UNWANTED_APP,
    @SerializedName("DANGEROUS")
    DANGEROUS,
    @SerializedName("HIGHLY_DANGEROUS")
    HIGHLY_DANGEROUS,
    @SerializedName("MALWARE")
    MALWARE;

    fun toThreatIndex(): ThreatIndex {
        return when(this) {
            UNKNOWN -> ThreatIndex.UNKNOWN
            SAFE -> ThreatIndex.SAFE
            POTENTIALLY_UNWANTED_APP -> ThreatIndex.POTENTIALLY_UNWANTED_APP
            DANGEROUS -> ThreatIndex.DANGEROUS
            HIGHLY_DANGEROUS -> ThreatIndex.HIGHLY_DANGEROUS
            MALWARE -> ThreatIndex.MALWARE
        }
    }
}

data class JsApk(val packageName: String, val signatureHash: String? = null) {
    fun toApkAllowList() = RaspConfig.ApkAllowlistItem(packageName, signatureHash)
}

private fun EmulatorDetection.toJson(): JSONObject {
    val o = JSONObject()
    o.put("isEmulator", isEmulator)
    detectedEmulatorType?.let { o.put("detectedEmulatorType", it) }
    o.put("emulatorDetectionProofs", JSONArray(emulatorDetectionProofs.map { it.name }))
    return o
}

private fun RootDetection.toJson(): JSONObject {
    val o = JSONObject()
    o.put("isRooted", isRooted)
    o.put("rootDetectionConfidence", rootDetectionConfidence)
    o.put("isRootCloaked", isRootCloaked)
    o.put("rootCloakDetectionConfidence", rootCloakDetectionConfidence)
    o.put("rootDetectionProofs", JSONArray(rootDetectionProofs.map { it.name }))
    return o
}

private fun ScreenSharingDetection.toJson(): JSONObject {
    val o = JSONObject()
    o.put("isScreenShared", isScreenShared)
    o.put("numberOfDisplays", numberOfDisplays)
    return o
}

private fun DebuggerDetection.toJson(): JSONObject {
    val o = JSONObject()
    o.put("isDebuggerAttached", isDebuggerAttached)
    o.put("isWaitingForDebugger", isWaitingForDebugger)
    o.put("debuggerType", JSONArray(debbuggerType.map { it.name }))
    return o
}

private fun TapjackingDetection.toJson(): JSONObject {
    val o = JSONObject()
    o.put("isTapjackingBlocked", isTapjackingBlocked)
    o.put("tapjackingCapableApps", JSONArray(tapjackingCapableApps))
    return o
}

private fun HttpProxyDetection.toJson(): JSONObject {
    val o = JSONObject()
    o.put("isHttpProxyEnabled", isHttpProxyEnabled)
    o.put("isUsingAutoConfig", isUsingAutoConfig())
    o.put("host", host)
    o.put("port", port)
    o.put("exclusionList", exclusionList)
    o.put("pacFileUrl", pacFileUrl?.toString())
    return o
}

private fun BiometryDetection.toJson(): JSONObject {
    val o = JSONObject()
    o.put("biometricStatus", biometricStatus.name)
    o.put("androidxLibStatus", androidxLibStatus)
    return o
}

private fun ActiveCallDetection.toJson(): JSONObject {
    val o = JSONObject()
    o.put("callState", callState.name)
    return o
}

private fun ApkThreat.toJson(): JSONObject {
    val o = JSONObject()
    o.put("evaluatedThreatIndex", evaluatedThreatIndex.name)
    o.put("malwareDetectionName", malwareDetectionName ?: JSONObject.NULL)
    o.put("mitigations", JSONArray(mitigations.map { it.name }))
    o.put("packageName", packageName)
    o.put("reasons", JSONArray(reasons.map { it.name }))
    o.put("suggestedThreatIndex", suggestedThreatIndex.name)
    o.put("threatIndex", threatIndex.name)
    o.put("threatInstaller", threatInstaller?.name ?: JSONObject.NULL)
    o.put("flags", JSONArray(flags.map { it.toJson() }))
    return o
}

private fun MalwareFlag.toJson(): JSONObject {
    val o = JSONObject()
    o.put("name", name)
    o.put("type", type.name)
    return o
}