//
// Copyright 2022 Wultra s.r.o.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions
// and limitations under the License.
//

import Foundation
import AppProtection

@objc(MalwarelyticsPlugin)
class MalwarelyticsPlugin: CDVPlugin {
    
    private var instance: AppProtectionService?
    
    @objc(isInitialized:)
    func isInitialized(command: CDVInvokedUrlCommand) {
        commandDelegate.send(CDVPluginResult(status: .ok, messageAs: instance != nil), callbackId: command.callbackId)
    }
    
    @objc(initialize:)
    func initialize(command: CDVInvokedUrlCommand) {
        
        guard let jsConfig: JsMalwarelyticsConfig = command.getObject() else {
            commandDelegate.send(CDVPluginResult(status: .error, messageAs: "WRONG CONFIG"), callbackId: command.callbackId)
            return
        }
        
        let identityConfig = AppProtectionIdentificationConfig(userId: "iosCordovaDemo", deviceId: "koberDemo")
        
        let raspConfig = AppProtectionRaspConfig(
            jailbreak: .notify,
            debugger: .notify,
            reverseEngineeringTools: .notify,
            httpProxy: .notify,
            repackage: .noAction([]),
            screenCapture: .notify)
        
        let eventsConfig = AppProtectionEventConfig(
            enableEventCollection: true,
            enableScreenshotTakenCollection: true)
        
        let config = AppProtectionConfig(
            username: "TODO",
            password: "TODO",
            signaturePublicKey: "TODO",
            clientIdentification: identityConfig,
            raspConfig: raspConfig,
            eventsConfig: eventsConfig,
            customerGroupingConfig: nil)
        
        let service = AppProtectionService(config: config)
        instance = service
        
        commandDelegate.send(CDVPluginResult(status: .ok), callbackId: command.callbackId)
    }
    
    // MARK: - RASP OBSERVER
    
    private var raspDelegate: RaspDelegate?
    
    @objc(setRaspCallback:)
    func setRaspCallback(command: CDVInvokedUrlCommand) {
        guard let instance = instance else {
            return
        }

        let delegate = RaspDelegate(commandDelegate: commandDelegate, command: command)
        instance.rasp.addDelegate(delegate)
        raspDelegate = delegate
    }
    
    @objc(clearRaspCallback:)
    func clearRaspCallback(command: CDVInvokedUrlCommand) {
        raspDelegate = nil
    }
    
    // MARK: - RASP FEATURES
    
    @objc(isJailbroken:)
    func isJailbroken(command: CDVInvokedUrlCommand) {
        guardInstance(command) { self.success(command, value: $0.rasp.isJailbroken) }
    }
    
    @objc(isDebuggerConnected:)
    func isDebuggerConnected(command: CDVInvokedUrlCommand) {
        guardInstance(command) { self.success(command, value: $0.rasp.isDebuggerConnected) }
    }
    
    @objc(isRepackaged:)
    func isRepackaged(command: CDVInvokedUrlCommand) {
        guardInstance(command) { self.success(command, value: $0.rasp.isRepackaged) }
    }
    
    @objc(isReverseEngineeringToolsPresent:)
    func isReverseEngineeringToolsPresent(command: CDVInvokedUrlCommand) {
        guardInstance(command) { self.success(command, value: $0.rasp.isReverseEngineeringToolsPresent) }
    }
    
    @objc(isHttpProxyEnabled:)
    func isHttpProxyEnabled(command: CDVInvokedUrlCommand) {
        guardInstance(command) { self.success(command, value: $0.rasp.isHttpProxyEnabled) }
    }
    
    @objc(isEmulator:)
    func isEmulator(command: CDVInvokedUrlCommand) {
        guardInstance(command) { self.success(command, value: $0.rasp.isEmulator) }
    }
    
    @objc(isScreenCaptured:)
    func isScreenCaptured(command: CDVInvokedUrlCommand) {
        guardInstance(command) { self.success(command, value: $0.rasp.isScreenCaptured) }
    }
    
    @objc(isSystemBiometryEnabled:)
    func isSystemBiometryEnabled(command: CDVInvokedUrlCommand) {
        guardInstance(command) { self.success(command, value: $0.rasp.isSystemBiometryEnabled) }
    }
    
    @objc(isSystemPasscodeEnabled:)
    func isSystemPasscodeEnabled(command: CDVInvokedUrlCommand) {
        guardInstance(command) { self.success(command, value: $0.rasp.isSystemPasscodeEnabled) }
    }

    // MARK: - UTILS
    
    private func guardInstance(_ command: CDVInvokedUrlCommand, closure: (AppProtectionService) -> Void) {
        guard let instance = instance else {
            commandDelegate.send(CDVPluginResult(status: .error, messageAs: "INSTANCE NOT INITIALIZED"), callbackId: command.callbackId)
            return
        }
        
        closure(instance)
    }
}

private struct JsMalwarelyticsConfig: Decodable {
    let clientId: String?
    let iosConfig: iOSConfig?
}

private struct iOSConfig: Decodable {
    
}

private let decoder = JSONDecoder()
private let encoder = JSONEncoder()

private extension CDVInvokedUrlCommand {
    func getObject<T: Decodable>(at: Int = 0) -> T? {
        guard let string = arguments[0] as? String, let data = string.data(using: .utf8) else {
            return nil
        }
        return try? decoder.decode(T.self, from: data)
    }
}

private extension CDVPlugin {
    func success<T>(_ command: CDVInvokedUrlCommand, value: T) {
        if let v = value as? Bool {
            commandDelegate.send(CDVPluginResult(status: .ok, messageAs: v), callbackId: command.callbackId)
        }
    }
}

private class RaspDelegate: AppProtectionRaspDelegate {
    
    private enum CallbackType: String, Codable {
        case debugger = "DEBUGGER"
        case jailbreak = "JAILBREAK"
        case repackaged = "REPACKAGED"
        case httpProxy = "HTTP_PROXY"
        case screenshotDetected = "SCREENSHOT_DETECTED"
        case screenCaptureDetected = "SCREEN_CAPTURE_CHANGED"
        case reverseTools = "REVERSE_TOOLS"
        case devicePasscodeChanged = "DEVICE_PASSCODE_CHANGED"
        case deviceBiometryChanged = "DEVICE_BIOMETRY_CHANGED"
    }
    
    private let command: CDVInvokedUrlCommand
    private let commandDelegate: CDVCommandDelegate
    
    init(commandDelegate: CDVCommandDelegate, command: CDVInvokedUrlCommand) {
        self.command = command
        self.commandDelegate = commandDelegate
    }
    
    deinit {
        commandDelegate.send(CDVPluginResult(status: .noResult), callbackId: command.callbackId)
    }
    
    private func report(_ event: CallbackType, data: Any? = nil) {
        var payload: [AnyHashable: Any] = ["type": event.rawValue]
        if let data = data {
            payload["payload"] = data
        }
        let result = CDVPluginResult(status: .ok, messageAs: payload)
        result?.setKeepCallbackAs(true)
        commandDelegate.send(result, callbackId: command.callbackId)
    }
    
    func debuggerDetected() {
        report(.debugger)
    }
    
    func jailbreakDetected() {
        report(.jailbreak)
    }
    
    func repackageDetected() {
        report(.repackaged)
    }
    
    func httpProxyEnabled() {
        report(.httpProxy)
    }
    
    func userScreenshotDetected() {
        report(.screenshotDetected)
    }
    
    func screenCapturedChanged(isCaptured: Bool) {
        report(.screenCaptureDetected, data: isCaptured)
    }
    
    func reverseEngineeringToolsDetected() {
        report(.reverseTools)
    }
    
    func systemPasscodeConfigurationChanged(enabled: Bool) {
        report(.devicePasscodeChanged, data: enabled)
    }
    
    func systemBiometryConfigurationChanged(enabled: Bool) {
        report(.deviceBiometryChanged, data: enabled)
    }
}
