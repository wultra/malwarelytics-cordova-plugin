//
// Copyright 2022 Wultra s.r.o.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions
// and limitations under the License.
//

import Foundation
import AppProtection

@objc(MalwarelyticsPlugin)
class MalwarelyticsPlugin: CDVPlugin {
    
    private var instance: AppProtectionService?
    
    @objc(isInitialized:)
    func isInitialized(command: CDVInvokedUrlCommand) {
        commandDelegate.send(CDVPluginResult(status: .ok, messageAs: instance != nil), callbackId: command.callbackId)
    }

    @objc(isOnline:)
    func isOnline(command: CDVInvokedUrlCommand) {
        guardInstance(command) { self.success(command, value: $0.online != nil) }
    }
    
    @objc(initialize:)
    func initialize(command: CDVInvokedUrlCommand) {
        
        guard instance == nil else {
            commandDelegate.send(CDVPluginResult(status: .error, messageAs: "already initialized"), callbackId: command.callbackId)
            return
        }
        
        guard let jsConfig: JsMalwarelyticsConfig = command.getObject() else {
            commandDelegate.send(CDVPluginResult(status: .error, messageAs: "WRONG CONFIG"), callbackId: command.callbackId)
            return
        }
        
        let identityConfig = AppProtectionIdentificationConfig(userId: jsConfig.clientId, deviceId: jsConfig.deviceId)
        let raspConfig = jsConfig.appleConfig?.raspConfig?.convert() ?? AppProtectionRaspConfig()
        let onlineConfig = jsConfig.appleConfig?.onlineConfig
        let configureInOfflineMode = Self.username.isEmpty

        let onlineConfigWithApiKeys: AppProtectionOnlineConfig? = configureInOfflineMode ? nil : .init(
            username: Self.username,
            password: Self.password,
            signaturePublicKey: Self.pubKey,
            clientIdentification: identityConfig,
            eventsConfig: onlineConfig?.eventsConfig?.convert() ?? AppProtectionEventConfig(),
            customerGroupingConfig: onlineConfig?.customerGrouping?.convert()
        )
        
        let config = AppProtectionConfig(
            raspConfig: raspConfig,
            onlineConfig: onlineConfigWithApiKeys)
        
        let service = AppProtectionService(config: config)
        instance = service
        
        success(command)
    }

    @objc(setClientId:)
    func setClientId(command: CDVInvokedUrlCommand) {
        guardInstance(command) {
            if let online = $0.online {
                online.clientIdentification.userId = command.arguments[0] as? String
                self.success(command)
                return
            }

            commandDelegate.send(CDVPluginResult(status: .error, messageAs: "Cannot set clientId in offline mode"), callbackId: command.callbackId)
        }
    }
    
    @objc(setDeviceId:)
    func setDeviceId(command: CDVInvokedUrlCommand) {
        guardInstance(command) {
            if let online = $0.online {
                online.clientIdentification.deviceId = command.arguments[0] as? String
                self.success(command)
                return
            }

            commandDelegate.send(CDVPluginResult(status: .error, messageAs: "Cannot set deviceId in offline mode"), callbackId: command.callbackId)
        }
    }
    
    // MARK: - RASP OBSERVER
    
    private var raspDelegate: RaspDelegate?
    
    @objc(setRaspCallback:)
    func setRaspCallback(command: CDVInvokedUrlCommand) {
        guard let instance = instance else {
            return
        }

        let delegate = RaspDelegate(commandDelegate: commandDelegate, command: command)
        instance.rasp.addDelegate(delegate)
        raspDelegate = delegate
    }
    
    @objc(clearRaspCallback:)
    func clearRaspCallback(command: CDVInvokedUrlCommand) {
        raspDelegate = nil
    }
    
    // MARK: - RASP FEATURES
    
    @objc(isJailbroken:)
    func isJailbroken(command: CDVInvokedUrlCommand) {
        guardInstance(command) { self.success(command, value: $0.rasp.isJailbroken) }
    }
    
    @objc(isDebuggerConnected:)
    func isDebuggerConnected(command: CDVInvokedUrlCommand) {
        guardInstance(command) { self.success(command, value: $0.rasp.isDebuggerConnected) }
    }
    
    @objc(isRepackaged:)
    func isRepackaged(command: CDVInvokedUrlCommand) {
        guardInstance(command) { self.success(command, value: $0.rasp.isRepackaged) }
    }
    
    @objc(isReverseEngineeringToolsPresent:)
    func isReverseEngineeringToolsPresent(command: CDVInvokedUrlCommand) {
        guardInstance(command) { self.success(command, value: $0.rasp.isReverseEngineeringToolsPresent) }
    }
    
    @objc(isHttpProxyEnabled:)
    func isHttpProxyEnabled(command: CDVInvokedUrlCommand) {
        guardInstance(command) { self.success(command, value: $0.rasp.isHttpProxyEnabled) }
    }
    
    @objc(isEmulator:)
    func isEmulator(command: CDVInvokedUrlCommand) {
        guardInstance(command) { self.success(command, value: $0.rasp.isEmulator) }
    }
    
    @objc(isScreenCaptured:)
    func isScreenCaptured(command: CDVInvokedUrlCommand) {
        guardInstance(command) { self.success(command, value: $0.rasp.isScreenCaptured) }
    }
    
    @objc(isSystemBiometryEnabled:)
    func isSystemBiometryEnabled(command: CDVInvokedUrlCommand) {
        guardInstance(command) { self.success(command, value: $0.rasp.isSystemBiometryEnabled) }
    }
    
    @objc(isSystemPasscodeEnabled:)
    func isSystemPasscodeEnabled(command: CDVInvokedUrlCommand) {
        guardInstance(command) { self.success(command, value: $0.rasp.isSystemPasscodeEnabled) }
    }

    @objc(isVpnActive:)
    func isVpnActive(command: CDVInvokedUrlCommand) {
        guardInstance(command) { self.success(command, value: $0.rasp.isVpnActive) }
    }

    @objc(isOnCall:)
    func isOnCall(command: CDVInvokedUrlCommand) {
        guardInstance(command) { self.success(command, value: $0.rasp.isOnCall) }
    }

    // MARK: - UTILS
    
    private func guardInstance(_ command: CDVInvokedUrlCommand, closure: (AppProtectionService) -> Void) {
        guard let instance = instance else {
            commandDelegate.send(CDVPluginResult(status: .error, messageAs: "INSTANCE NOT INITIALIZED"), callbackId: command.callbackId)
            return
        }
        
        closure(instance)
    }
}

private struct JsMalwarelyticsConfig: Decodable {
    let clientId: String?
    let deviceId: String?
    let appleConfig: JsAppleConfig?
    
    struct JsAppleConfig: Decodable {
        let raspConfig: JsRaspConfig?
        let onlineConfig: JsOnlineConfig?
    }
    
    struct JsEventConfig: Decodable {
        let enableEventCollection: Bool?
        let enableScreenshotTakenCollection: Bool?
        
        func convert() -> AppProtectionEventConfig {
            return AppProtectionEventConfig(enableEventCollection: enableEventCollection ?? true, enableScreenshotTakenCollection: enableScreenshotTakenCollection ?? true)
        }
    }
    
    struct JsCustomerGroupingConfig: Decodable {
        let sourceBundleId: String?
        let appBundleId: String?
        let audienceGroupId: String?
        
        func convert() -> AppProtectionCustomerGroupingConfig {
            return AppProtectionCustomerGroupingConfig(sourceBundleId: sourceBundleId, appBundleId: appBundleId, audienceGroupId: audienceGroupId)
        }
    }
    
    struct JsRaspConfig: Decodable {
        let jailbreak: JsDetection?
        let debugger: JsDebuggerDetection?
        let reverseEngineeringTools: JsDetection?
        let httpProxy: JsDetection?
        let repackage: JsRepackageDetection?
        let screenCapture: JsScreenCaptureDetection?
        let vpnDetection: JsDetection?
        let callDetection: JsSimpleDetection?
        
        func convert() -> AppProtectionRaspConfig {
            return AppProtectionRaspConfig(
                jailbreak: jailbreak?.convert() ?? .notify,
                debugger: debugger?.convert() ?? .noAction,
                reverseEngineeringTools: reverseEngineeringTools?.convert() ?? .notify,
                httpProxy: httpProxy?.convert() ?? .notify,
                repackage: repackage?.convert() ?? .noAction([]),
                screenCapture: screenCapture?.convert() ?? .notify,
                vpnDetection: vpnDetection?.convert() ?? .notify,
                callDetection: callDetection?.convert() ?? .notify
            )
        }
    }

    struct JsOnlineConfig: Decodable {
        let eventsConfig: JsEventConfig?
        let customerGrouping: JsCustomerGroupingConfig?
    }

    struct JsDebuggerDetection: Decodable {
        let action: JsDebuggerAction
        let exitUrl: String?
        
        func convert() -> AppProtectionRaspConfig.DebuggerDetectionConfig {
            switch action {
            case .noAction: return .noAction
            case .notify: return .notify
            case .block: return .block
            case .exit: return .exit(exitUrl)
            }
        }
    }

    struct JsRepackageDetection: Decodable {
        let action: JsDetectionAction
        let base64EncodedTrustedCertificates: [String]?
        let exitUrl: String?
        
        func convert() -> AppProtectionRaspConfig.RepackageConfig {
            switch action {
            case .noAction: return .noAction(base64EncodedTrustedCertificates?.toTrustedCerts() ?? [])
            case .notify: return .notify(base64EncodedTrustedCertificates?.toTrustedCerts() ?? [])
            case .exit: return .exit(base64EncodedTrustedCertificates?.toTrustedCerts() ?? [], exitUrl)
            }
        }
    }

    struct JsScreenCaptureDetection: Decodable {
        let action: JsScreenCaptureAction
        let exitUrl: String?
        let overlay: JsOverlay?
        
        func convert() -> AppProtectionRaspConfig.ScreenCaptureDetectionConfig {
            switch action {
            case .noAction: return .noAction
            case .notify: return .notify
            case .hide: return .hide(/*overlay.convert() ?? */.default)
            case .exit: return .exit(exitUrl)
            }
        }
    }

    struct JsDetection: Decodable {
        let action: JsDetectionAction
        let exitUrl: String?
        
        func convert() -> AppProtectionRaspConfig.DetectionConfig {
            switch action {
            case .noAction: return .noAction
            case .notify: return .notify
            case .exit: return .exit(exitUrl)
            }
        }
    }

    struct JsSimpleDetection: Decodable {
        let action: JsSimpleDetectionAction

        func convert() -> AppProtectionRaspConfig.SimpleDetectionConfig {
            switch action {
            case .noAction: return .noAction
            case .notify: return .notify
            }
        }
    }

    enum JsDebuggerAction: String, Decodable {
        case noAction = "NO_ACTION"
        case notify = "NOTIFY"
        case block = "BLOCK"
        case exit = "EXIT"
    }

    enum JsScreenCaptureAction: String, Decodable {
        case noAction = "NO_ACTION"
        case notify = "NOTIFY"
        case hide = "HIDE"
        case exit = "EXIT"
    }

    enum JsDetectionAction: String, Decodable {
        case noAction = "NO_ACTION"
        case notify = "NOTIFY"
        case exit = "EXIT"
    }

    enum JsSimpleDetectionAction: String, Decodable {
        case noAction = "NO_ACTION"
        case notify = "NOTIFY"
    }

    struct JsOverlay: Decodable {
        let type: JsOverlayType
        let color: JsColor?
        let image: JsImage?

        func convert() -> AppProtectionRaspConfig.ScreenCaptureDetectionConfig.Overlay {
            switch type {
                case .`default`: return .`default`
                case .color:
                    var ovrl: AppProtectionRaspConfig.ScreenCaptureDetectionConfig.Overlay
                    if let ucolor = color {
                        ovrl = .color(ucolor.convert())
                    } else {
                        ovrl = .`default`
                    }
                    return ovrl
                case .image: 
                    var ovrl: AppProtectionRaspConfig.ScreenCaptureDetectionConfig.Overlay
                    if let uimage = image {
                        ovrl = .image(uimage.convert())
                    } else {
                        ovrl = .`default`
                    }
                    return ovrl
            }
        }
    }

    enum JsOverlayType: String, Decodable {
        case `default` = "DEFAULT"
        case color = "COLOR"
        case image = "IMAGE"
    }

    struct JsColor: Decodable {
        let red: Int
        let green: Int
        let blue: Int
        let alpha: Int

        func convert() -> UIColor {
            return UIColor(
                red: CGFloat(Double(red)/255.0),
                green: CGFloat(Double(green)/255.0), 
                blue: CGFloat(Double(blue)/255.0), 
                alpha: CGFloat(Double(alpha)/255.0)
            )
        }
    }

    struct JsImage: Decodable {
        let name: String

        func convert() -> UIImage {
            return UIImage(imageLiteralResourceName: name)
        }
    }
}

private let decoder = JSONDecoder()
private let encoder = JSONEncoder()

private extension Array where Element == String {
    func toTrustedCerts() -> [AppProtectionTrustedCert] {
        return compactMap { AppProtectionTrustedCert(withBase64EncodedString: $0) }
    }
}

private extension CDVInvokedUrlCommand {
    func getObject<T: Decodable>(at: Int = 0) -> T? {
        guard let string = arguments[0] as? String, let data = string.data(using: .utf8) else {
            return nil
        }
        return try? decoder.decode(T.self, from: data)
    }
}

private extension CDVPlugin {
    func success<T>(_ command: CDVInvokedUrlCommand, value: T) {
        if let v = value as? Bool {
            commandDelegate.send(CDVPluginResult(status: .ok, messageAs: v), callbackId: command.callbackId)
        }
    }
    func success(_ command: CDVInvokedUrlCommand) {
        commandDelegate.send(CDVPluginResult(status: .ok), callbackId: command.callbackId)
    }
}

private class RaspDelegate: AppProtectionRaspDelegate {
    
    private enum CallbackType: String, Codable {
        case debugger = "DEBUGGER"
        case jailbreak = "JAILBREAK"
        case repackaged = "REPACKAGED"
        case httpProxy = "HTTP_PROXY"
        case screenshotDetected = "SCREENSHOT_DETECTED"
        case screenCaptureDetected = "SCREEN_CAPTURE_CHANGED"
        case reverseTools = "REVERSE_TOOLS"
        case devicePasscodeChanged = "DEVICE_PASSCODE_CHANGED"
        case deviceBiometryChanged = "DEVICE_BIOMETRY_CHANGED"
        case vpnChanged = "VPN_CHANGED"
        case onCallChanged = "ON_CALL_CHANGED"
    }
    
    private let command: CDVInvokedUrlCommand
    private let commandDelegate: CDVCommandDelegate
    
    init(commandDelegate: CDVCommandDelegate, command: CDVInvokedUrlCommand) {
        self.command = command
        self.commandDelegate = commandDelegate
    }
    
    deinit {
        commandDelegate.send(CDVPluginResult(status: .noResult), callbackId: command.callbackId)
    }
    
    private func report(_ event: CallbackType, data: Any? = nil) {
        var payload: [AnyHashable: Any] = ["type": event.rawValue]
        if let data = data {
            payload["payload"] = data
        }
        let result = CDVPluginResult(status: .ok, messageAs: payload)
        result?.setKeepCallbackAs(true)
        commandDelegate.send(result, callbackId: command.callbackId)
    }
    
    func debuggerDetected() {
        report(.debugger)
    }
    
    func jailbreakDetected() {
        report(.jailbreak)
    }
    
    func repackageDetected() {
        report(.repackaged)
    }
    
    func httpProxyEnabled() {
        report(.httpProxy)
    }
    
    func userScreenshotDetected() {
        report(.screenshotDetected)
    }
    
    func screenCapturedChanged(isCaptured: Bool) {
        report(.screenCaptureDetected, data: isCaptured)
    }
    
    func reverseEngineeringToolsDetected() {
        report(.reverseTools)
    }
    
    func systemPasscodeConfigurationChanged(enabled: Bool) {
        report(.devicePasscodeChanged, data: enabled)
    }
    
    func systemBiometryConfigurationChanged(enabled: Bool) {
        report(.deviceBiometryChanged, data: enabled)
    }

    func vpnChanged(active: Bool) {
        report(.vpnChanged, data: active)
    }

    func onCallChanged(isOnCall: Bool) {
        report(.onCallChanged, data: isOnCall)
    }
}
