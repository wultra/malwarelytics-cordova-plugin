//
// Copyright 2020 Wultra s.r.o.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions
// and limitations under the License.
//

//
// This hook will parse the malwarelytics.xml file 
// and prepares all necesarry files that are needed for proper
// malwarelytics configuration.
//

const fs = require("fs");
const xml2js = require("xml2js");
const { ConfigParser } = require('cordova-common');

const configClassName = "MalwarelyticsConfig"; // name of the malwarelytics config kotlin class
const configPackage = "com.wultra.android.cordova.malwarelytics.plugin"; // package undner which the config class will reside
const configPath = "./platforms/android/app/src/main/java/" + configPackage.split(".").join("/"); // path where to copy the the kotlin config file
const configFile = `${configPath}/${configClassName}.kt`; // name of the kotlin konfig file
const appResFolder = "./platforms/android/app/src/main/res/"; // folder where resources of the android app are placed
const malwarelyticsConfigFile = "./malwarelytics.xml"; // integrators configuration xml path
const appConfigFile = "./config.xml"; // cordova app config file path

// Copies all all files from given folder to android resource folder
function copyResources(dirPath, rootPath) {

    if (!fs.existsSync(dirPath)) {
        throw `Malwarelytics: Cannot copy ${dirPath}. It doesn't exist.`;
    }

    if (!fs.statSync(dirPath).isDirectory()) {
        throw `Malwarelytics: Cannot copy ${dirPath}. It's not a directory.`;
    }
    
    // get all the files from the folder
    const files = fs.readdirSync(dirPath);

    files.forEach(file => {

        // relative path to the project folder
        const filePath = dirPath + "/" + file;

        // if the file is directory, copy its content recursively
        if (fs.statSync(filePath).isDirectory()) {
            copyResources(filePath, rootPath || dirPath);
        } else {
            // destination of the file (where it will be copied)
            let dest = appResFolder + filePath.replace(rootPath + "/", "");

            // make sure that the folder exists
            fs.mkdirSync(appResFolder + "/" + dirPath.replace(rootPath, ""), { recursive: true});

            // copy the file
            fs.copyFile(filePath, dest, error => {
                if (error) {
                    throw `Malwarelytics: failed to copy custom resource file: ${error}`;
                } else {
                    console.log(`Resource copied to the destiantion ${dest}`);
                }
            });
        }
    })
}

// main malwareelytics integration function
function integrate() {

    // check that cordova config.xml file exists
    if (!fs.existsSync(appConfigFile)) {
        throw "Malwarelytics: Missing apps config.xml file";
    }

    // parse the config file
    const appConfig = new ConfigParser(appConfigFile);
    const packageName = appConfig.android_packageName() || appConfig.packageName();

    // we need package name
    if (packageName == null) {
        throw "Malwarelytics: App bundle cannot be obtained.";
    }

    // make esure that the integrator prepared the config file
    if (!fs.existsSync(malwarelyticsConfigFile)) {
        throw `Malwarelytics: Missing configuration file in ${malwarelyticsConfigFile}`;
    }

    // parse the config file and start processing
    const xmlFile = fs.readFileSync(malwarelyticsConfigFile).toString();
    const parser = new xml2js.Parser();
    parser.parseString(xmlFile, (error, config) => {
        
        // cannot be parsed
        if (error) {
            throw `Malwarelytics: ${error}`;
        }

        function prependPackageName(resource) {
            if (resource != null) {
                return `${packageName}.${resource}`;
            }
            return resource;
        }

        const serviceConfig = config.malwarelytics["service"][0].$;
        const m2config = config.malwarelytics["maven"][0].$;
        const uiConfig = config.malwarelytics["ui"][0].$;

        // login items
        const username = serviceConfig.username || null;
        const password = serviceConfig.password || null;
        const apiKey = serviceConfig.publicKey || null;

        // maven items
        let m2url = m2config.url || "https://wultra.jfrog.io/artifactory/malwarelytics-android/";
        const m2user = m2config.username || null;
        const m2pwd = m2config.password || null;

        // optional UI items
        const resourceFolder = uiConfig.resourcesFolder || null;
        const theme = prependPackageName(uiConfig.theme);
        const notificationIcon = prependPackageName(uiConfig.notificationIcon);
        const settingsIcon = prependPackageName(uiConfig.settingsIcon);
        const deleteIcon = prependPackageName(uiConfig.deleteIcon);

        // library configuration

        // if maven configuration was provided, set it up
        if (m2user != null && m2pwd != null) {

            // prepare private maven configuration
            const content = `// THIS FILE WAS GENERATED BY THE INTEGRATE-MALWARELYTICS SCRIPT
allprojects {
    repositories {
        maven {
            logger.lifecycle('using m2url ${m2url}')
            credentials {
                username '${m2user}'
                password '${m2pwd}'
            }
            url '${m2url}'
        }
    }
}`;

            const mwGradleFile = "malwarelytics-maven.gradle";
            fs.writeFileSync(`./platforms/android/app/${mwGradleFile}`, content);

            const buildGradleFile = "./platforms/android/app/build.gradle";

            let bgContent = fs.readFileSync(buildGradleFile);
            const applyRow = `apply from: '${mwGradleFile}'`;

            // if build.gradle doesnt incclude maven repo, prepend it.
            if (bgContent.indexOf(applyRow) == -1) {
                bgContent = `${applyRow}\n${bgContent}`;
                fs.writeFileSync(buildGradleFile, bgContent);
            }
        } else {
            throw `Malwarelytics: missing malwarelytics maven configuration`;
        }

        // check for mandatory config items
        if (password == null || username == null) {
            throw `Malwarelytics: <service> 'username' or 'password' is not set in config file ${malwarelyticsConfigFile}`;
        }

        // prepare the contents of the kotlin file
        const content = `package ${configPackage}

class ${configClassName} {

    companion object {
        const val USER_NAME = "${username}"
        const val PASSWORD = "${password}"
        val API_PUBLIC_KEY: String? = ${apiKey == null ? "null" : `\"${apiKey}\"`}
        val THEME: Int? = ${theme}
        val NOTIFICATION_ICON: Int? = ${notificationIcon}
        val SETTINGS_ICON: Int? = ${settingsIcon}
        val DELETE_ICON: Int? = ${deleteIcon}
    }
}`;

        // write the contents of the file
        fs.writeFile(configFile, content, function(error) {
            if (error) {
                throw `Malwarelytics: failed to generate config file: ${error}`;
            } else {
                console.log("Malwarelytics: credentials file generated")
            }
        });

        if (resourceFolder != null) {
            copyResources(resourceFolder);
        }
    });
}

let deferral;

module.exports = function(ctx) {
    try {
        deferral = require('q').defer();
        integrate();
        deferral.resolve();
    } catch(e) {
        let msg = e.toString();
        console.dir(e);
        deferral.reject(msg);
        return deferral.promise;
    }
};