//
// Copyright 2020 Wultra s.r.o.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions
// and limitations under the License.
//

//
// This hook will parse the malwarelytics.xml file 
// and prepares all necesarry files that are needed for proper
// malwarelytics configuration.
//

const fs = require("fs");
const xml2js = require("xml2js");
const { ConfigParser } = require('cordova-common');

const configClassName = "MalwarelyticsConfig"; // name of the malwarelytics config kotlin class
const configPackage = "com.wultra.android.cordova.malwarelytics.plugin"; // package undner which the config class will reside
const configPath = "./platforms/android/app/src/main/java/" + configPackage.split(".").join("/"); // path where to copy the the kotlin config file
const configFile = `${configPath}/${configClassName}.kt`; // name of the kotlin konfig file
const appResFolder = "./platforms/android/app/src/main/res/"; // folder where resources of the android app are placed
const malwarelyticsConfigFile = "./malwarelytics.xml"; // integrators configuration xml path
const appConfigFile = "./config.xml"; // cordova app config file path

// Copies all all files from given folder to android resource folder
function copyResources(dirPath, rootPath) {

    if (!fs.existsSync(dirPath)) {
        throw `Malwarelytics: Cannot copy ${dirPath}. It doesn't exist.`;
    }

    if (!fs.statSync(dirPath).isDirectory()) {
        throw `Malwarelytics: Cannot copy ${dirPath}. It's not a directory.`;
    }
    
    // get all the files from the folder
    const files = fs.readdirSync(dirPath);

    files.forEach(file => {

        // relative path to the project folder
        const filePath = dirPath + "/" + file;

        // if the file is directory, copy its content recursively
        if (fs.statSync(filePath).isDirectory()) {
            copyResources(filePath, rootPath || dirPath);
        } else {
            // destination of the file (where it will be copied)
            let dest = appResFolder + filePath.replace(rootPath + "/", "");

            // make sure that the folder exists
            fs.mkdirSync(appResFolder + "/" + dirPath.replace(rootPath, ""), { recursive: true});

            // copy the file
            fs.copyFile(filePath, dest, error => {
                if (error) {
                    throw `Malwarelytics: failed to copy custom resource file: ${error}`;
                } else {
                    console.log(`Resource copied to the destiantion ${dest}`);
                }
            });
        }
    })
}

// main malwareelytics integration function
function integrate() {

    // check that cordova config.xml file exists
    if (!fs.existsSync(appConfigFile)) {
        throw "Malwarelytics: Missing apps config.xml file";
    }

    // parse the config file
    const appConfig = new ConfigParser(appConfigFile);
    const packageName = appConfig.android_packageName() || appConfig.packageName();

    // we need package name
    if (packageName == null) {
        throw "Malwarelytics: App bundle cannot be obtained.";
    }

    // make esure that the integrator prepared the config file
    if (!fs.existsSync(malwarelyticsConfigFile)) {
        throw `Malwarelytics: Missing configuration file in ${malwarelyticsConfigFile}`;
    }

    // parse the config file and start processing
    const xmlFile = fs.readFileSync(malwarelyticsConfigFile).toString();
    const parser = new xml2js.Parser();
    parser.parseString(xmlFile, (error, config) => {
        
        // cannot be parsed
        if (error) {
            throw `Malwarelytics: ${error}`;
        }

        let username = config.malwarelytics["username"] || null;
        let password = config.malwarelytics["password"] || null;
        let theme = config.malwarelytics["theme"] || null;
        let notificationIcon = config.malwarelytics["notification-icon"] || null;
        let resourceFolder = config.malwarelytics["resources-folder"] || null;
        if (theme != null) {
            theme = `${packageName}.${theme}`
        }
        if (notificationIcon != null) {
            notificationIcon = `${packageName}.${notificationIcon}`
        }
        let aarPath = (config.malwarelytics["library-path"]) || null;

        // copy the native (android) library
        if (aarPath != null) {
            const libFolder = "./platforms/android/app/libs/";
            fs.mkdirSync(libFolder, { recursive: true });
            fs.copyFile(aarPath[0], libFolder + "antivirus.aar", error => {
                if (error) {
                    throw `Malwarelytics: failed to copy library file: ${error}`;
                }
            });
        } else {
            throw `Malwarelytics: missing path to native library inside the config file`;
        }

        // check for mandatory config items
        if (password == null || username == null) {
            throw `Malwarelytics: 'username' or 'password' is not set in config file ${malwarelyticsConfigFile}`;
        }

        // prepare the contents of the kotlin file
        const content = `package ${configPackage}

class ${configClassName} {

    companion object {
        const val USER_NAME = "${username}"
        const val PASSWORD = "${password}"
        val THEME: Int? = ${theme}
        val NOTIFICATION_ICON: Int? = ${notificationIcon}
    }
}`;

        // write the contents of the file
        fs.writeFile(configFile, content, function(error) {
            if (error) {
                throw `Malwarelytics: failed to generate config file: ${error}`;
            } else {
                console.log("Malwarelytics: credentials file generated")
            }
        });

        if (resourceFolder != null) {
            copyResources(resourceFolder[0]);
        }
    });
}

let deferral;

module.exports = function(ctx) {
    try {
        deferral = require('q').defer();
        integrate();
        deferral.resolve();
    } catch(e) {
        let msg = e.toString();
        console.dir(e);
        deferral.reject(msg);
        return deferral.promise;
    }
};