/**
 * RASP component of the Malwarelytics for Android.
 */
class MalwarelyticsAndroidRASP extends __MPAndroidService {
  
    /** Adds observer that will be called when security event occures (for example when debugger connects). */
    setObserver(observer: MalwarelyticsAndroidRASPObserver) {
      return this.call("setRaspCallback", (result: {type: RaspCallbackType, payload: any}) => {
        switch (result.type) {
          case RaspCallbackType.DEBUGGER:  {
            observer.debuggerDetected(result.payload as boolean);
            break;
          }
          case RaspCallbackType.EMULATOR: {
            observer.emulatorDetected(result.payload as EmulatorDetection);
            break;
          }
          case RaspCallbackType.REPACKAGING: {
            observer.repackagingDetected(result.payload as RepackagingResult);
            break;
          }
          case RaspCallbackType.ROOT: {
            observer.rootDetected(result.payload as RootDetection);
            break;
          }
          case RaspCallbackType.SCREEN_SHARING: {
            observer.screenSharingDetected(result.payload as boolean);
            break;
          }
          case RaspCallbackType.TAPJACKING: {
            observer.tapjackingDetected(result.payload as TapjackingDetection);
            break;
          }
          case RaspCallbackType.HTTP_PROXY: {
            observer.httpProxyDetected(result.payload as HttpProxyDetection);
            break;
          }
          case RaspCallbackType.ADB_STATUS: {
            observer.adbStatusDetected(result.payload as boolean);
            break;
          }
        }
      }, null);
    }
  
    async clearObserver(): Promise<void> {
      return await this.callAsync("clearRaspCallback");
    }
  
    /** Detailed information about the state of the root on this device. */
    async getRootDetection(): Promise<RootDetection> {
      return await this.getInfo(__MPRaspRetection.ROOT_DETECTION);
    }
  
    /** If the device is rooted */
    async isDeviceRooted(): Promise<Boolean> {
      return await this.getBoolState(__MPRaspRetection.IS_ROOTED);
    }
  
    /** Detailed information about the state of the emulator detection. */
    async getEmulatorDetection(): Promise<EmulatorDetection> {
      return await this.getInfo(__MPRaspRetection.EMULATOR_INFO);
    }
  
    /** If app is running on emulator. */
    async isDeviceEmulator(): Promise<Boolean> {
      return await this.getBoolState(__MPRaspRetection.IS_EMULATOR);
    }
  
    /** Detailed information about the debugger. */
    async getDebuggerDetection(): Promise<DebuggerDetection> {
      return await this.getInfo(__MPRaspRetection.DEBUGGER_INFO);
    }
  
    /** If debugger is attached to this app. */
    async isDebuggerAttached(): Promise<Boolean> {
      return await this.getBoolState(__MPRaspRetection.IS_DEBUGGER);
    }
  
    /** Detailed info about the repackaging. */
    async getAppRepackaged(): Promise<RepackagingResult> {
      return await this.getInfo(__MPRaspRetection.REPACKAGE_INFO);
    }
  
    /** Detailed info about screen sharing. */
    async getScreenSharingDetection(): Promise<ScreenSharingDetection> {
      return await this.getInfo(__MPRaspRetection.SCREEN_SHARED_INFO);
    }
  
    /** If the screen is shared. */
    async isScreenShared(): Promise<Boolean> {
      return await this.getBoolState(__MPRaspRetection.IS_SCREEN_SHARED);
    }
  
    /** If screen lock is set. */
    async isDeviceUsingScreenLock(): Promise<Boolean> {
      return await this.getBoolState(__MPRaspRetection.SCREEN_LOCK_ENABLED);
    }
  
    /** If google play protect is enabled. */
    async isPlayProtectEnabled(): Promise<Boolean> {
      return await this.getBoolState(__MPRaspRetection.PLAY_PROTECT_ENABLED);
    }
  
    /** If disalowed scren reader is enabled. */
    async isNotAllowedScreenReaderEnabled(): Promise<Boolean> {
      return await this.getBoolState(__MPRaspRetection.NOT_ALLOWED_SCREEN_READER_ENABLED);
    }
  
    /** If app that cn do tapjacking is present. */
    async isBadTapjackingCapableAppPresent(): Promise<Boolean> {
      return await this.getBoolState(__MPRaspRetection.IS_BAD_TAPJACKING_CAPABLE_APP_PRESENT);
    }
  
    /** Detailed info about tapjacking. */
    async getTapjackingDetection(): Promise<TapjackingDetection> {
      return await this.getInfo(__MPRaspRetection.TAPJACKING_INFO);
    }

    /** Detailed info about http proxy. */
    async getHttpProxyDetection(): Promise<HttpProxyDetection> {
      return await this.getInfo(__MPRaspRetection.HTTP_PROXY_INFO);
    }

    /** If http proxy is enabled. */
    async isHttpProxyEnabled(): Promise<Boolean> {
      return await this.getBoolState(__MPRaspRetection.IS_HTTP_PROXY)
    }

    /** If developer options are enabled. */
    async isDeveloperOptionsEnabled(): Promise<Boolean> {
      return await this.getBoolState(__MPRaspRetection.DEVELOPER_OPTIONS)
    }

    /** If ADB is enabled. */
    async isAdbEnabled(): Promise<Boolean> {
      return await this.getBoolState(__MPRaspRetection.ADB_STATUS)
    }
  
    private async getInfo<T>(detection: __MPRaspRetection): Promise<T> {
      return await this.callAsync("raspInfo", detection);
    }
  
    private async getBoolState(detection: __MPRaspRetection): Promise<Boolean> {
      const result: number = await this.callAsync("raspInfo", detection);
      return result == 1;
    }
  }
  
  interface MalwarelyticsAndroidRASPObserver {
    debuggerDetected(detected: boolean): void;
    emulatorDetected(emulatorDetection: EmulatorDetection): void;
    repackagingDetected(repackagingResult: RepackagingResult): void;
    rootDetected(rootDetection: RootDetection): void;
    screenSharingDetected(screenSharingDetected: boolean): void;
    tapjackingDetected(tapjackingDetection: TapjackingDetection): void;
    httpProxyDetected(httpProxyDetection: HttpProxyDetection): void;
    adbStatusDetected(adbStatus: boolean): void;
  }