/**
 * Javascript wrapper around native kotlin malwarelytics code.
 * Malwarelytics plugin can be accessed in cordova app via `window.plugins.malwarelytics` property.
 */
class MalwarelyticsPlugin extends __MPService {

  /** Features for antivirus component. */
  readonly antivirus = new Antivirus();

  /** Features for RASP component. */
  readonly rasp = new Rasp();

  /**
   * If the malwarelytics are initialized.
   */
  async isInitialized(): Promise<boolean> {
    return await this.callAsync("isInitialized");
  }

  /**
   * Initializes themalwarelytics with provided configuration.
   * Note that username and password needs to be set inside the plugin kotlin file MalwarelyticsCredentials.kt
   * 
   * @param config Configuration file
   */
  async initialize(config: MalwarelyticsConfig): Promise<void> {
    const stringified = JSON.stringify(config);
    return await this.callAsync("initialize", stringified);
  }

  /**
   * Sets new clinet id that will be sent to the backend for user identification.
   * Pass null to remove the current client id (for example when user logged-out).
   * 
   * @param clientId Client id. Null for deleting the value
   */
  async setClientId(clientId: string): Promise<void> {
    return await this.callAsync("setClientId", clientId);
  }

  // - UTIL METHODS --

  /**
   * Utility helper method that changes to language of the Malwarelytics UI.
   * The language code follows the ISO 639-1 standard.
   * 
   * Note that the language configuration is not persisted and you'll need to set it 
   * every time the app is started.
   * 
   * @param language ISO 639-1 language code
   */
  async changeAppLanguage(language: string): Promise<void> {
    return await this.callAsync("changeAppLanguage", language);
  }
}

class Antivirus extends __MPService {
  
  constructor() {
    super()
  }

  /**
   * Schedules a job that will execute smart protection run. Note that this is asynchronous and
   * can take some time.
   */
  async triggerSmartProtection(): Promise<void> {
    return await this.callAsync("triggerSmartProtection");
  }

  /**
   * Returns list of all applications with the malware evaluation.
   */
   async getThreatList(): Promise<{items: ApkThreat[]}> {
    return await this.callAsync("getThreatList");
  }

  /**
   * Gets more information for the package name of the application.
   * 
   * @param packageName Package name of the application
   */
  async getApkInfo(packageName: String): Promise<ApkInfo> {
    return await this.callAsync("getApkInfo", packageName);
  }
}

class Rasp extends __MPService {

  constructor() { super() }

  setObserver(observer: RaspObserver) {
    return this.call("setRaspCallback", (result: {type: RaspCallbackType, payload: any}) => {
      switch (result.type) {
        case RaspCallbackType.DEBUGGER:  {
          observer.debuggerDetected(result.payload as boolean);
          break;
        }
        case RaspCallbackType.EMULATOR: {
          observer.emulatorDetected(result.payload as EmulatorDetection);
          break;
        }
        case RaspCallbackType.REPACKAGING: {
          observer.repackagingDetected(result.payload as RepackagingResult);
          break;
        }
        case RaspCallbackType.ROOT: {
          observer.rootDetected(result.payload as RootDetection);
          break;
        }
        case RaspCallbackType.SCREEN_SHARING: {
          observer.screenSharingDetected(result.payload as boolean);
          break;
        }
        case RaspCallbackType.TAPJACKING: {
          observer.tapjackingDetected(result.payload as TapjackingDetection);
          break;
        }
        case RaspCallbackType.HTTP_PROXY: {
          observer.httpProxyDetected(result.payload as HttpProxyDetection);
          break;
        }
      }
    }, null);
  }

  async clearObserver(): Promise<void> {
    return await this.callAsync("clearRaspCallback");
  }

  /** Detailed information about the state of the root on this device. */
  async getRootDetection(): Promise<RootDetection> {
    return await this.getInfo(__MPRaspRetection.ROOT_DETECTION);
  }

  /** If the device is rooted */
  async isDeviceRooted(): Promise<Boolean> {
    return await this.getBoolState(__MPRaspRetection.IS_ROOTED);
  }

  /** Detailed information about the state of the emulator detection. */
  async getEmulatorDetection(): Promise<EmulatorDetection> {
    return await this.getInfo(__MPRaspRetection.EMULATOR_INFO);
  }

  /** If app is running on emulator. */
  async isDeviceEmulator(): Promise<Boolean> {
    return await this.getBoolState(__MPRaspRetection.IS_EMULATOR);
  }

  /** Detailed information about the debugger. */
  async getDebuggerDetection(): Promise<DebuggerDetection> {
    return await this.getInfo(__MPRaspRetection.DEBUGGER_INFO);
  }

  /** If debugger is attached to this app. */
  async isDebuggerAttached(): Promise<Boolean> {
    return await this.getBoolState(__MPRaspRetection.IS_DEBUGGER);
  }

  /** Detailed info about the repackaging. */
  async getAppRepackaged(): Promise<RepackagingResult> {
    return await this.getInfo(__MPRaspRetection.REPACKAGE_INFO);
  }

  /** Detailed info about screen sharing. */
  async getScreenSharingDetection(): Promise<ScreenSharingDetection> {
    return await this.getInfo(__MPRaspRetection.SCREEN_SHARED_INFO);
  }

  /** If the screen is shared. */
  async isScreenShared(): Promise<Boolean> {
    return await this.getBoolState(__MPRaspRetection.IS_SCREEN_SHARED);
  }

  /** If screen lock is set. */
  async isDeviceUsingScreenLock(): Promise<Boolean> {
    return await this.getBoolState(__MPRaspRetection.SCREEN_LOCK_ENABLED);
  }

  /** If google play protect is enabled. */
  async isPlayProtectEnabled(): Promise<Boolean> {
    return await this.getBoolState(__MPRaspRetection.PLAY_PROTECT_ENABLED);
  }

  /** If disalowed scren reader is enabled. */
  async isNotAllowedScreenReaderEnabled(): Promise<Boolean> {
    return await this.getBoolState(__MPRaspRetection.NOT_ALLOWED_SCREEN_READER_ENABLED);
  }

  /** If app that cn do tapjacking is present. */
  async isBadTapjackingCapableAppPresent(): Promise<Boolean> {
    return await this.getBoolState(__MPRaspRetection.IS_BAD_TAPJACKING_CAPABLE_APP_PRESENT);
  }

  /** Detailed info about tapjacking. */
  async getTapjackingDetection(): Promise<TapjackingDetection> {
    return await this.getInfo(__MPRaspRetection.TAPJACKING_INFO);
  }

  /** Detailed info about http proxy. */
  async getHttpProxyDetection(): Promise<HttpProxyDetection> {
    return await this.getInfo(__MPRaspRetection.HTTP_PROXY_INFO);
  }

  private async getInfo<T>(detection: __MPRaspRetection): Promise<T> {
    return await this.callAsync("raspInfo", detection);
  }

  private async getBoolState(detection: __MPRaspRetection): Promise<Boolean> {
    const result: number = await this.callAsync("raspInfo", detection);
    return result == 1;
  }
}

interface RaspObserver {
  debuggerDetected(detected: boolean): void;
  emulatorDetected(emulatorDetection: EmulatorDetection): void;
  repackagingDetected(repackagingResult: RepackagingResult): void;
  rootDetected(rootDetection: RootDetection): void;
  screenSharingDetected(screenSharingDetected: boolean): void;
  tapjackingDetected(tapjackingDetection: TapjackingDetection): void;
  httpProxyDetected(httpProxyDetection: HttpProxyDetection): void;
}

declare var module: any; // global variable passed by cordova
module.exports = new MalwarelyticsPlugin();
