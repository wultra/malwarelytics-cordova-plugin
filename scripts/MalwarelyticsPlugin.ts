/**
 * Javascript wrapper around native kotlin malwarelytics code.
 * Malwarelytics plugin can be accessed in cordova app via `window.plugins.malwarelytics` property.
 */
class MalwarelyticsPlugin {

  private readonly w = new __MPWrapper();

  /** Features for antivirus component */
  antivirus = new Antivirus(this.w);

  /** Features for RASP component. */
  rasp = new Rasp(this.w);

  /**
   * If the malwarelytics are initialized.
   * @param success Returns the result
   * @param error Called on error
   */
  isInitialized(success: successCallback<boolean>, error: errorCallback = null) {
    this.w.call("isInitialized", wrapBoolResp(success), error);
  }

  /**
   * Initializes themalwarelytics with provided configuration.
   * Note that username and password needs to be set inside the plugin kotlin file MalwarelyticsCredentials.kt
   * 
   * @param config Configuration file
   * @param success When the configuration was success
   * @param error Called on error
   */
  initialize(config: MalwarelyticsConfig, success: successCallback = null, error: errorCallback = null) {
    const stringified = JSON.stringify(config);
    this.w.call("initialize", success, error, stringified);
  }

  /**
   * Sets new clinet id that will be sent to the backend for user identification.
   * Pass null to remove the current client id (for example when user logged-out).
   * 
   * @param clientId Client id. Null for deleting the value
   * @param success When the id was set
   * @param error Called on error
   */
  setClientId(clientId: string, success: successCallback = null, error: errorCallback = null) {
    this.w.call("setClientId", success, error, clientId);
  }

  // - UTIL METHODS --

  /**
   * Utility helper method that changes to language of the Malwarelytics UI.
   * The language code follows the ISO 639-1 standard.
   * 
   * Note that the language configuration is not persisted and you'll need to set it 
   * every time the app is started.
   * 
   * @param language ISO 639-1 language code
   * @param success When language change was success
   * @param error  When language change failed
   */
  changeAppLanguage(language: string, success: successCallback = null, error: errorCallback = null) {
    this.w.call("changeAppLanguage", success, error, language);
  }
}

class Antivirus {

  constructor(private w: __MPWrapper) {}

  /**
   * Schedules a job that will execute smart protection run. Note that this is asynchronous and
   * can take some time.
   * 
   * @param success When the job was scheduled
   * @param error Called on error
   */
  triggerSmartProtection(success: successCallback = null, error: errorCallback = null) {
    this.w.call("triggerSmartProtection", success, error);
  }

  /**
   * Returns list of all applications with the malware evaluation.
   * 
   * @param success APKs
   * @param error Called on error
   */
   getThreatList(success: successCallback<{items: ApkThreat[]}> = null, error: errorCallback = null) {
    this.w.call("getThreatList", success, error);
  }

  /**
   * Gets more information for the package name of the application.
   * 
   * @param packageName Package name of the application
   * @param success Information about the application with the label and icon.
   * @param error Called on error
   */
  getApkInfo(packageName: String, success: successCallback<ApkInfo> = null, error: errorCallback = null) {
    this.w.call("getApkInfo", success, error, packageName);
  }
}

class Rasp {

  constructor(private w: __MPWrapper) {}

  getRootDetection(success: successCallback<RootDetection>, error: errorCallback = null) {
    this.getInfo(__MPRaspRetection.ROOT_DETECTION, success, error);
  }

  isDeviceRooted(success: successCallback<boolean>, error: errorCallback = null) {
    this.getInfo(__MPRaspRetection.IS_ROOTED, wrapBoolResp(success), error);
  }

  getEmulatorDetection(success: successCallback<EmulatorDetection>, error: errorCallback = null) {
    this.getInfo(__MPRaspRetection.EMULATOR_INFO, success, error);
  }

  isDeviceEmulator(success: successCallback<boolean>, error: errorCallback = null) {
    this.getInfo(__MPRaspRetection.IS_EMULATOR, wrapBoolResp(success), error);
  }

  getDebuggerDetection(success: successCallback<DebuggerDetection>, error: errorCallback = null) {
    this.getInfo(__MPRaspRetection.DEBUGGER_INFO, success, error);
  }

  isDebuggerAttached(success: successCallback<boolean>, error: errorCallback = null) {
    this.getInfo(__MPRaspRetection.IS_DEBUGGER, wrapBoolResp(success), error);
  }

  getAppRepackaged(success: successCallback<RepackagingResult>, error: errorCallback = null) {
    this.getInfo(__MPRaspRetection.REPACKAGE_INFO, success, error);
  }

  getScreenSharingDetection(success: successCallback<ScreenSharingDetection>, error: errorCallback = null) {
    this.getInfo(__MPRaspRetection.SCREEN_SHARED_INFO, success, error);
  }

  isScreenShared(success: successCallback<boolean>, error: errorCallback = null) {
    this.getInfo(__MPRaspRetection.IS_SCREEN_SHARED, wrapBoolResp(success), error);
  }

  isDeviceUsingScreenLock(success: successCallback<boolean>, error: errorCallback = null) {
    this.getInfo(__MPRaspRetection.SCREEN_LOCK_ENABLED, wrapBoolResp(success), error);
  }

  isPlayProtectEnabled(success: successCallback<boolean>, error: errorCallback = null) {
    this.getInfo(__MPRaspRetection.PLAY_PROTECT_ENABLED, wrapBoolResp(success), error);
  }

  private getInfo<T>(detection: __MPRaspRetection, success: successCallback<T>, error: errorCallback = null) {
    this.w.call("raspInfo", success, error, detection);
  }
}

function wrapBoolResp(success: successCallback<boolean>) {
  return (data: number) => { success(data === 1) }
}

type successCallback<T = void> = (result: T) => void;
type errorCallback = (err: MalwarelyticsError) => void;

declare var module: any; // global variable passed by cordova
module.exports = new MalwarelyticsPlugin();
