/**
 * Malwarelytics configuration.
 */
export interface MalwarelyticsConfig {
    /**
     * Malwarelytics in silent mode does not show any UI. Default is true.
     */
    enableSilentMode?: boolean;
    /**
     * How often will be antivirus database checked (hourly). Default is 48 hours.
     */
    onlineCheckIntervalHours?: number;
    /**
     * If databse should be performend on SDK initialize. Default is true.
     */
    updateOnInitialize?: boolean;
    /**
     * Custom identifier of the user. You can set it later via setClientId method.
     */
    clientId?: string;
    /**
     * ISO 639-1 language code that the app will be used for UI localization.
     */
    languageCode?: string;
}
/**
 * Each type matches to specific error case
 */
export declare type MalwarelyticsErrorType = "PLUGIN_UNKNOWN_ACTION" | "PLUGIN_ALREADY_INITIALIZED" | "PLUGIN_NOT_INITIALIZED" | "MISSING_ARGUMENTS" | "INITIALIZE_MISSING_CREDENTIALS" | "TRIGGER_SMART_PROTECTION_UPDATE_FAILED" | "TRIGGER_SMART_PROTECTION_FAILED" | "UTILS_LANG_CHANGE_FAILED" | "THREAT_LIST_FAILED" | "APK_INFO_NOT_AVAILABLE";
declare class MalwarelyticsError {
    readonly type: MalwarelyticsErrorType;
    readonly data?: any;
    readonly description: string;
    constructor(type: MalwarelyticsErrorType, description: string, data?: any);
}
/**
 * Javascript wrapper around native kotlin malwarelytics code.
 * Malwarelytics plugin can be accessed in cordova app via `window.plugins.malwarelytics` property.
 */
export declare class MalwarelyticsPlugin {
    /**
     * If the malwarelytics are initialized.
     * @param success Returns the result
     * @param error Called on error
     */
    isInitialized(success: successCallback<boolean>, error?: errorCallback): void;
    /**
     * Initializes themalwarelytics with provided configuration.
     * Note that username and password needs to be set inside the plugin kotlin file MalwarelyticsCredentials.kt
     *
     * @param config Configuration file
     * @param success When the configuration was success
     * @param error Called on error
     */
    initialize(config: MalwarelyticsConfig, success?: successCallback, error?: errorCallback): void;
    /**
     * Schedules a job that will execute smart protection run. Note that this is asynchronous and
     * can take some time.
     *
     * @param success When the job was scheduled
     * @param error Called on error
     */
    triggerSmartProtection(success?: successCallback, error?: errorCallback): void;
    /**
     * Sets new clinet id that will be sent to the backend for user identification.
     * Pass null to remove the current client id (for example when user logged-out).
     *
     * @param clientId Client id. Null for deleting the value
     * @param success When the id was set
     * @param error Called on error
     */
    setClientId(clientId: string, success?: successCallback, error?: errorCallback): void;
    /**
     * Returns list of all applications with the malware evaluation.
     *
     * @param success APKs
     * @param error Called on error
     */
    getThreatList(success?: successCallback<{
        items: ApkThreat[];
    }>, error?: errorCallback): void;
    /**
     * Gets more information for the package name of the application.
     *
     * @param packageName Package name of the application
     * @param success Information about the application with the label and icon.
     * @param error Called on error
     */
    getApkInfo(packageName: String, success?: successCallback<ApkInfo>, error?: errorCallback): void;
    /**
     * Utility helper method that changes to language of the Malwarelytics UI.
     * The language code follows the ISO 639-1 standard.
     *
     * Note that the language configuration is not persisted and you'll need to set it
     * every time the app is started.
     *
     * @param language ISO 639-1 language code
     * @param success When language change was success
     * @param error  When language change failed
     */
    changeAppLanguage(language: string, success?: successCallback, error?: errorCallback): void;
    private createFailCallback;
}
declare type successCallback<T = void> = (result: T) => void;
declare type errorCallback = (err: MalwarelyticsError) => void;
/**
 * Information about android apk.
 */
export interface ApkInfo {
    /**
     * Application name as displayed in the system.
     */
    label: String;
    /**
     * Base64 encode PNG icon in the original size.
     * You can use it in html as `<img src="data:image/jpeg;base64,${apkInfo.icon}" width="96" />`
     */
    icon?: String;
}
/**
 * An apk with analyzed threats.
 */
export interface ApkThreat {
    /** Package name (application Id) of the app posing a threat to the current app. */
    packageName: string;
    /** Threat index indicating severity of the threat. */
    threatIndex: ThreatIndex;
    /** Optional name of malware detection. This is not bound to the thratIndex, can appear independently. */
    malwareDetectionName?: string;
    /** Set of recommended mitigations for handling the threat. */
    mitigations: ThreatMitigation[];
    /** Evaluated threat reasons marking what is dangerous about the app. */
    reasons: ThreatReason[];
    /** Store the app was installed from (for example google play). */
    threatInstaller: ThreatInstaller;
}
/**
 * A threat level that is posed by an app.
 *
 * MALWARE:
 * The found threats clearly indicate that the app is a malware.
 *
 * HIGHLY_DANGEROUS:
 * The found threats indicate that the app is highly dangerous
 * to the current app.
 * It uses multiple potential attack vectors
 * including techniques directly targeting the current app.
 *
 * DANGEROUS:
 * The found threats indicate that the app is dangerous
 * to the current app.
 * Is uses multiple potential attack vectors.
 * However, no technique directly targeting the current app was detected.
 *
 * POTENTIALLY_UNWANTED_APP:
 * The found threats indicate that the app might be potentially dangerous.
 * For example it declares potentially dangerous permissions.
 * However it it quite possible that the app is legitimate.
 *
 * SAFE:
 * There are no found threats.
 *
 * UNKNOWN:
 * The threat is unknown.
 * The app was probably not found.
 * In case of suggestions, there's none.
 */
export declare type ThreatIndex = "MALWARE" | "HIGHLY_DANGEROUS" | "DANGEROUS" | "POTENTIALLY_UNWANTED_APP" | "SAFE" | "UNKNOWN";
/**
 * Installer app of an apk.
 *
 * STORE_GOOGLE_PLAY: The app was installed via Google Play
 * STORE_HUAWEI_APP_GALLERY: The app was installed via Huawei App Gallery
 * STORE_SAMSUNG_GALAXY_STORE: The app was installed via Samsung Galaxy Store
 * STORE_APTOIDE: The app was installed via Aptoide
 */
export declare type ThreatInstaller = "STORE_GOOGLE_PLAY" | "STORE_HUAWEI_APP_GALLERY" | "STORE_SAMSUNG_GALAXY_STORE" | "STORE_APTOIDE";
export declare type ThreatMitigation = "WARNING_SCREEN" | "NOTIFICATION" | "SHOW_WEB" | "KILL_APP" | "KILL_APP_SHOW_WEB";
/**
 * Evaluated flag for an apk threat.
 * The flag risk the other app is posing.
 *
 * ACCESSIBILITY: Accesibility
 * SMS_ACCESS: Read sms, receive sms, notification listener
 * SCREEN_OVERRIDE: Task hijacking, screen overlay
 * INSTALLER: Can install apps
 * UNINSTALLER: Can uninstall apps
 * EVADER: Hides it's internals/function
 * OUTSIDE_GOOGLE_PLAY: Not installed via Google Play
 * CALLER: Can play with your calls, e.g. it can setup a call forwarding of your calls
 * PRELOADED_APP: The app is preloaded on the device
 * PRIVILEGED_APP: The app is privileged (system privileges)
 * DEVELOPMENT_OR_TEST: The app is debuggable
 *
 */
export declare type ThreatReason = "ACCESSIBILITY" | "SMS_ACCESS" | "SCREEN_OVERRIDE" | "INSTALLER" | "UNINSTALLER" | "EVADER" | "OUTSIDE_GOOGLE_PLAY" | "CALLER" | "PRELOADED_APP" | "PRIVILEGED_APP" | "DEVELOPMENT_OR_TEST";
