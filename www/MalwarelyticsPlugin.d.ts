declare enum __MPRaspDetection {
    IS_ROOTED = "IS_ROOTED",
    ROOT_DETECTION = "ROOT_DETECTION",
    IS_EMULATOR = "IS_EMULATOR",
    EMULATOR_INFO = "EMULATOR_INFO",
    IS_DEBUGGER = "IS_DEBUGGER",
    DEBUGGER_INFO = "DEBUGGER_INFO",
    REPACKAGE_INFO = "REPACKAGE_INFO",
    IS_SCREEN_SHARED = "IS_SCREEN_SHARED",
    SCREEN_SHARED_INFO = "SCREEN_SHARED_INFO",
    IS_BAD_TAPJACKING_CAPABLE_APP_PRESENT = "IS_BAD_TAPJACKING_CAPABLE_APP_PRESENT",
    TAPJACKING_INFO = "TAPJACKING_INFO",
    IS_HTTP_PROXY = "IS_HTTP_PROXY",
    HTTP_PROXY_INFO = "HTTP_PROXY_INFO",
    IS_VPN = "IS_VPN",
    ADB_STATUS = "ADB_STATUS",
    IS_ACTIVE_CALL = "IS_ACTIVE_CALL",
    ACTIVE_CALL_INFO = "ACTIVE_CALL_INFO",
    APP_PRESENCE_INFO = "APP_PRESENCE_INFO",
    NOT_ALLOWED_SCREEN_READER_ENABLED = "NOT_ALLOWED_SCREEN_READER_ENABLED",
    SCREEN_READER_INFO = "SCREEN_READER_INFO",
    SCREEN_LOCK_ENABLED = "SCREEN_LOCK_ENABLED",
    BIOMETRY = "BIOMETRY",
    PLAY_PROTECT_ENABLED = "PLAY_PROTECT_ENABLED",
    DEVELOPER_OPTIONS = "DEVELOPER_OPTIONS"
}
declare class __MPService {
    private readonly pluginName;
    constructor();
    protected callAsync<T>(name: string, ...args: any[]): Promise<T>;
    protected call<T>(name: string, success: (result: T) => void, error: (err: MalwarelyticsError) => void, ...args: any[]): void;
}
/**
 * Bridge for Malwarelytics for Android
 */
declare class __MPAndroidService extends __MPService {
    private readonly platform;
    private isAndroid;
    constructor();
    protected callAsync<T>(name: string, ...args: any[]): Promise<T>;
    protected call<T>(name: string, success: (result: T) => void, error: (err: MalwarelyticsError) => void, ...args: any[]): void;
}
/**
 * Bridge for Malwarelytics for Apple
 */
declare class __MPAppleService extends __MPService {
    private readonly platform;
    private isIos;
    constructor();
    protected callAsync<T>(name: string, ...args: any[]): Promise<T>;
    protected call<T>(name: string, success: (result: T) => void, error: (err: MalwarelyticsError) => void, ...args: any[]): void;
}
/**
 * Malwarelytics features for the Android platform.
 */
declare class MalwarelyticsAndroid extends __MPAndroidService {
    /** Features for antivirus component. */
    readonly antivirus: MalwarelyticsAndroidAntivirus;
    /** Features for RASP component. */
    readonly rasp: MalwarelyticsAndroidRASP;
    /**
     * Utility helper method that changes to language of the Malwarelytics UI.
     * The language code follows the ISO 639-1 standard.
     *
     * Note that the language configuration is not persisted and you'll need to set it
     * every time the app is started.
     *
     * @param language ISO 639-1 language code
     */
    changeAppLanguage(language: string): Promise<void>;
    /**
     * Get result of the initialization.
     */
    getInitializationResult(): Promise<InitializationResult>;
}
/**
* Antivirus component of the Malwarelytics for Android.
*/
declare class MalwarelyticsAndroidAntivirus extends __MPAndroidService {
    /**
    * Schedules a job that will execute smart protection run. Note that this is asynchronous and
    * can take some time.
    *
    * @param performOnlineUpdate Optional argument to indicate that online update is not desired.
    * If false only local data will be used.
    */
    triggerSmartProtection(performOnlineUpdate?: Boolean): Promise<SmartProtectionResult>;
    /**
    * Returns list of all applications with the malware evaluation.
    */
    getThreatList(): Promise<{
        items: ApkThreat[];
    }>;
    /**
    * Gets more information for the package name of the application.
    *
    * @param packageName Package name of the application
    */
    getApkInfo(packageName: String): Promise<ApkInfo>;
    /**
     * Get information about the last updates.
     *
     * Primarily intended for troubleshooting.
     *
     * @returns Information about latest update successes and failures.
     */
    getLastUpdateInfo(): Promise<UpdateInfo>;
    /** Set observer that is triggered when a suggestion update completes. */
    setUpdateObserver(observer: MalwarelyticsAndroidUpdateObserver): void;
    /** Clear observer for suggestion updates. */
    clearUpdateObserver(): void;
}
/** Observer for update results. */
interface MalwarelyticsAndroidUpdateObserver {
    /**
     * Called when an update was finished regardless of a success or a failure.
     *
     * Returned data indicated the update result:
     * - Successful update:
     *     @see ObservedUpdateInfo.failureReason is null
     * - Partially successful update:
     *     @see ObservedUpdateInfo.failureReason is not null
     *     and @see ObservedUpdateInfo.updatedApps is not empty
     * - Failed update:
     *     and @see ObservedUpdateInfo.failureReason is not null
     *     and @see ObservedUpdateInfo.updatedApps is empty */
    onSuggestionUpdated(observedUpdateInfo: ObservedUpdateInfo): void;
}
/**
 * RASP component of the Malwarelytics for Android.
 */
declare class MalwarelyticsAndroidRASP extends __MPAndroidService {
    /** Adds observer that will be called when security event occures (for example when debugger connects). */
    setObserver(observer: MalwarelyticsAndroidRASPObserver): void;
    clearObserver(): Promise<void>;
    /** If the device is rooted */
    isDeviceRooted(): Promise<Boolean>;
    /** Detailed information about the state of the root on this device. */
    getRootDetection(): Promise<RootDetection>;
    /** If app is running on emulator. */
    isDeviceEmulator(): Promise<Boolean>;
    /** Detailed information about the state of the emulator detection. */
    getEmulatorDetection(): Promise<EmulatorDetection>;
    /** If debugger is attached to this app. */
    isDebuggerAttached(): Promise<Boolean>;
    /** Detailed information about the debugger. */
    getDebuggerDetection(): Promise<DebuggerDetection>;
    /** Detailed info about the repackaging. */
    getAppRepackaged(): Promise<RepackagingResult>;
    /** If the screen is shared. */
    isScreenShared(): Promise<Boolean>;
    /** Detailed info about screen sharing. */
    getScreenSharingDetection(): Promise<ScreenSharingDetection>;
    /** If app that cn do tapjacking is present. */
    isBadTapjackingCapableAppPresent(): Promise<Boolean>;
    /** Detailed info about tapjacking. */
    getTapjackingDetection(): Promise<TapjackingDetection>;
    /** If http proxy is enabled. */
    isHttpProxyEnabled(): Promise<Boolean>;
    /** Detailed info about http proxy. */
    getHttpProxyDetection(): Promise<HttpProxyDetection>;
    /** If VPN is enabled. */
    isVpnEnabled(): Promise<Boolean>;
    /** If ADB is enabled. */
    isAdbEnabled(): Promise<Boolean>;
    /** If there's ongoing active call at the moment. */
    isCallActive(): Promise<Boolean>;
    /** Detailed info about active call. */
    getActiveCallDetection(): Promise<ActiveCallDetection>;
    /** Detailed info about application presence. */
    getAppPresenceDetection(): Promise<AppPresenceDetection>;
    /** If disalowed scren reader is enabled. */
    isNotAllowedScreenReaderEnabled(): Promise<Boolean>;
    /** Detailed info about screen readers. */
    getScreenReaderDetection(): Promise<ScreenReaderDetection>;
    /** If screen lock is set. */
    isDeviceUsingScreenLock(): Promise<Boolean>;
    /** Obtain biometry detection. */
    getBiometryDetection(): Promise<BiometryDetection>;
    /** If google play protect is enabled. */
    isPlayProtectEnabled(): Promise<Boolean>;
    /** If developer options are enabled. */
    isDeveloperOptionsEnabled(): Promise<Boolean>;
    private getInfo;
    private getBoolState;
}
interface MalwarelyticsAndroidRASPObserver {
    debuggerDetected(detected: boolean): void;
    emulatorDetected(emulatorDetection: EmulatorDetection): void;
    repackagingDetected(repackagingResult: RepackagingResult): void;
    rootDetected(rootDetection: RootDetection): void;
    screenSharingDetected(screenSharingDetection: ScreenSharingDetection): void;
    screenReaderDetected(screenReaderDetection: ScreenReaderDetection): void;
    tapjackingDetected(tapjackingDetection: TapjackingDetection): void;
    httpProxyDetected(httpProxyDetection: HttpProxyDetection): void;
    vpnDetected(vpnEnabled: boolean): void;
    adbStatusDetected(adbStatus: boolean): void;
    activeCallDetected(activeCallDetection: ActiveCallDetection): void;
    appPresenceDetected(appPresenceDetection: AppPresenceDetection): void;
}
/**
 * Malwarelytics features for the Apple platforms.
 */
declare class MalwarelyticsApple extends __MPAppleService {
    /** Features for RASP component. */
    readonly rasp: MalwarelyticsAppleRASP;
    /**
     * If the malwarelytics are initialized in the online mode.
     */
    isOnline(): Promise<boolean>;
    /**
     * Obtain list of DetectableApp.KnownApp items that are predefined in native iOS library.
     */
    getKnownDetectableApps(): Promise<MalwarelyticsAppleDetectableApp[]>;
}
/**
 * Malwarelytics RASP features for the Apple platforms.
 */
declare class MalwarelyticsAppleRASP extends __MPAppleService {
    /** Adds observer that will be called when security event occures (for example when debugger connects). */
    setObserver(observer: MalwarelyticsAppleRASPObserver): void;
    clearObserver(): Promise<void>;
    /** If the device is Jailbroken. */
    isDeviceJailbroken(): Promise<Boolean>;
    /** If the app is being debugged. */
    isDebuggerConnected(): Promise<Boolean>;
    /** If the app is signed with different signature. */
    isRepackaged(): Promise<Boolean>;
    /** True when reverse engineering tools are present. */
    isReverseEngineeringToolsPresent(): Promise<Boolean>;
    /** If HTTP proxy is enabled in iOS Settings. */
    isHttpProxyEnabled(): Promise<Boolean>;
    /** If the app is running on emulator. */
    isEmulator(): Promise<Boolean>;
    /** If device screen is being captured. */
    isScreenCaptured(): Promise<Boolean>;
    /** If the user is using (has enrolled) biometry. */
    isSystemBiometryEnabled(): Promise<Boolean>;
    /** If the user has passcode enabled in the system (device lock). */
    isSystemPasscodeEnabled(): Promise<Boolean>;
    /** If VPN is active on the device. */
    isVpnActive(): Promise<Boolean>;
    /** If there is active (phone) call. */
    isOnCall(): Promise<Boolean>;
    /**
     * Obtain the list of installed apps.
     * Available apps to check needs to be configured in the `AppProtectionRaspConfig.appPresence` configuration.
     *
     * @returns list of installed apps.
     */
    installedApps(): Promise<MalwarelyticsAppleDetectableApp[]>;
}
interface MalwarelyticsAppleRASPObserver {
    debuggerDetected(): void;
    jailbreakDetected(): void;
    repackageDetected(): void;
    httpProxyEnabled(): void;
    userScreenshotDetected(): void;
    screenCapturedChanged(isCaptured: boolean): void;
    reverseEngineeringToolsDetected(): void;
    systemPasscodeConfigurationChanged(enabled: boolean): void;
    systemBiometryConfigurationChanged(enabled: boolean): void;
    vpnChanged(active: boolean): void;
    onCallChanged(isOnCall: boolean): void;
    installedAppsChanged(installedApps: MalwarelyticsAppleDetectableApp[]): void;
}
declare enum AppleRaspCallbackType {
    DEBUGGER = "DEBUGGER",
    JAILBREAK = "JAILBREAK",
    REPACKAGED = "REPACKAGED",
    HTTP_PROXY = "HTTP_PROXY",
    SCREENSHOT_DETECTED = "SCREENSHOT_DETECTED",
    SCREEN_CAPTURE_CHANGED = "SCREEN_CAPTURE_CHANGED",
    REVERSE_TOOLS = "REVERSE_TOOLS",
    DEVICE_PASSCODE_CHANGED = "DEVICE_PASSCODE_CHANGED",
    DEVICE_BIOMETRY_CHANGED = "DEVICE_BIOMETRY_CHANGED",
    VPN_CHANGED = "VPN_CHANGED",
    ON_CALL_CHANGED = "ON_CALL_CHANGED",
    INSTALLED_APPS_CHANGED = "INSTALLED_APPS_CHANGED"
}
/** Configuration of the Malwarelytics SDK for the Android platform. */
interface MalwarelyticsAndroidConfig {
    /** ISO 639-1 language code that the app will be used for UI localization. */
    languageCode?: string;
    /** Antivirus component configuration. If not set, default values are used. */
    antivirusConfig?: MalwarelyticsAndroidAntivirusConfig;
    /** RASP component configuration. If not set, default values are used. */
    raspConfig?: MalwarelyticsAndroidRaspConfig;
    /** Configuration of customer grouping and naming in the Malwarelytics web console. */
    customerGrouping?: MalwarelyticsAndroidCustomerGroupingConfig;
    /** Configurre device fingerprinting. */
    fingerprint?: MalwarelyticsAndroidFingerprintType;
}
/** Configuration of customer grouping and naming in the Malwarelytics web console. */
interface MalwarelyticsAndroidCustomerGroupingConfig {
    /**
     * Set custom source package name.
     * The value has to match application credentials defined in the web application.
     *
     * Maximum length of the value is 255 characters.
     */
    sourcePackageName?: string;
    /**
     * Set app app package name to obtain extra granularity
     * of the information displayed in the web application.
     * Distinguishes application purposes or segmentation in one organization.
     *
     * Maximum length of the value is 255 characters.
     */
    appPackageName?: string;
    /**
     * Set audience group ID to obtain extra granularity
     * of the information displayed in the web application.
     * Distinguishes users from different customer systems (RETAIL, CORPORATE, ...).
     *
     * Maximum length of the value is 20 characters.
     */
    audienceGroupId?: string;
}
/**
 * Type of device fingerprinting performed.
 * NONE - Fingerprinting is completely turned off on all devices.
 *        No fingerprinting method is used.
 * BASIC - Basic fingerprinting.
 *         Fingerprinting uses only some fingerprinting methods. Only the methods that are safe on all devices.
 * SAFE - Safe fingerprinting.
 *        Using full fingerprinting on non-problematic device.
 *        Using basic fingerprinting on problematic devices. Those are some Pixel devices with Android 14.
 * FULL - Full fingerprinting.
 *        Using all available fingerprinting methods.
 */
type MalwarelyticsAndroidFingerprintType = "NONE" | "BASIC" | "SAFE" | "FULL";
/**
 * Antivirus component configuration for Android platform
 */
interface MalwarelyticsAndroidAntivirusConfig {
    /** Malwarelytics in silent mode does not show any UI. Default is true. */
    enableSilentMode?: boolean;
    /** How often will be antivirus database checked (hourly). Default is 48 hours. */
    onlineCheckIntervalHours?: number;
    /** If databse should be performend on SDK initialize. Default is true. */
    updateOnInitialize?: boolean;
}
/**
 * Runtime Application Self-Protection Configuration for Android platform
 */
interface MalwarelyticsAndroidRaspConfig {
    /** Emulator detection configuration. The default action is `NOTIFY`. */
    emulator?: MalwarelyticsAndroidDetectionConfig;
    /** Root detection configuration. The default action is `NOTIFY`. */
    root?: MalwarelyticsAndroidRootDetectionConfig;
    /** Debugger detection configuration. The default action is `NOTIFY`. */
    debugger?: MalwarelyticsAndroidDebuggerDetectionConfig;
    /** Repackaging detection configuration. The default action is `EXIT`. */
    repackage?: MalwarelyticsAndroidRepackageDetectionConfig;
    /** Screen sharing detection configuration. The default action is `NOTIFY`. */
    screenSharing?: MalwarelyticsAndroidDetectionConfig;
    /** Screenshot and screen recording blocking configuration. The default action is `BLOCK`. */
    screenshot?: MalwarelyticsAndroidBlockConfig;
    /** Screen reader blocking configuration. The default action is `BLOCK`. */
    screenReader?: MalwarelyticsAndroidScreenReaderBlockConfig;
    /** Process name handling configuraiton. The default value is `USE_STEALTHY`. */
    processName?: MalwarelyticsAndroidProcessNameConfig;
    /** Tapjacking block configuration. The default value is `BLOCK`. */
    tapjacking?: MalwarelyticsAndroidTapjackingBlockConfig;
    /** HTTP proxy detection configuration. The default action is `NOTIFY`. */
    httpProxy?: MalwarelyticsAndroidDetectionConfig;
    /** VPN detection configuration. The default action is `NOTIFY`. */
    vpn?: MalwarelyticsAndroidDetectionConfig;
    /** ADB detection configuration. The default action is `NOTIFY`. */
    adb?: MalwarelyticsAndroidAdbDetectionConfig;
    /** Active call detection configuration. The default action is `NOTIFY`. */
    activeCall?: MalwarelyticsAndroidSimpleDetectionConfig;
    /** App presence detection configuration. The default action is `NOTIFY`. */
    appPresence?: MalwarelyticsAndroidAppPresenceDetectionConfig;
}
/** Data that describes Android APK. */
interface Apk {
    packageName: string;
    signatureHash?: string;
}
/** Configuration of the basic detection behavior */
interface MalwarelyticsAndroidDetectionConfig {
    /** Behavior of the detection */
    action: MalwarelyticsAndroidDetectionAction;
    /** This URL will be open in the default browser when app is terminated in case that the `action` is `EXIT`. */
    exitUrl?: string;
}
/** Configuration of the root detection behavior */
interface MalwarelyticsAndroidRootDetectionConfig {
    /** Behavior of the detection */
    action: MalwarelyticsAndroidDetectionAction;
    /** This URL will be open in the default browser when app is terminated in case that the `action` is `EXIT`. */
    exitUrl?: string;
    /** Minimum confidence value of heuristic root detections that triggers app termination. */
    exitOnRootMinConfidence?: number;
}
/** Configuration of the debugger detection behavior */
interface MalwarelyticsAndroidDebuggerDetectionConfig {
    /** Behavior of the detection */
    action: MalwarelyticsAndroidDetectionAction;
    /** This URL will be open in the default browser when app is terminated in case that the `action` is `EXIT`. */
    exitUrl?: string;
    /** Minimum confidence value of heuristic root detections that triggers app termination. */
    debuggerTypes?: DebuggerType[];
}
/** Configuration of the repackage detection behavior */
interface MalwarelyticsAndroidRepackageDetectionConfig {
    /** Behavior of the detection */
    action: MalwarelyticsAndroidDetectionAction;
    /** This URL will be open in the default browser when app is terminated in case that the `action` is `EXIT`. */
    exitUrl?: string;
    /** Base64-encoded SHA-1 of signing certificate(s). One or more values can be set. */
    signatureHash?: string[];
}
/** Configuration of the basic block behavior */
interface MalwarelyticsAndroidBlockConfig {
    /** Behavior of the detection */
    action: MalwarelyticsAndroidBlockAction;
}
/** Configuration of the screen readers block behavior */
interface MalwarelyticsAndroidScreenReaderBlockConfig {
    /** Behavior of the detection */
    action: MalwarelyticsAndroidBlockAction;
    /** Defines collection of allowed screen readers. It is empty by default. */
    allowedScreenReaders?: Apk[];
}
/** Configuration of the process name handling */
interface MalwarelyticsAndroidProcessNameConfig {
    /** Behavior of the handling */
    action: MalwarelyticsAndroidProcessNameAction;
    /** Sets custom name to be used for the app process name. When not set a random name is used. */
    customProcessName?: string;
}
/** Configuration of the tapjacking block behavior */
interface MalwarelyticsAndroidTapjackingBlockConfig {
    /** Behavior of the handling */
    action: MalwarelyticsAndroidBlockAction;
    /**
     * Defines sensitivity for blocking tapjacking. The default value is ThreatIndex.HIGHLY_DANGEROUS.
     */
    blockTapjackingSensitivity?: ThreatIndex;
    /**
     * Define whether to ignore system apps in blocking tapjacking. The default value is false
     */
    ignoreTapjackingSystemApps?: boolean;
    /**
     * List of allowed tapjacking-capable apps.
     *
     * Used for fine-tuning tapjacking protection.
     * It enables to ignore apps that are capable of tapjacking.
     * Use to get rid of false-positives.
     */
    allowedTapjackingApps?: Apk[];
}
/** Configuration of the adb detection behavior */
interface MalwarelyticsAndroidAdbDetectionConfig {
    /** Behavior of the detection */
    action: MalwarelyticsAndroidAdbDetectionAction;
    /** This URL will be open in the default browser when app is terminated in case that the `action` is `EXIT`. */
    exitUrl?: string;
}
/** Configuration of the simple detection behavior */
interface MalwarelyticsAndroidSimpleDetectionConfig {
    /** Behavior of the detection */
    action: MalwarelyticsAndroidSimpleDetectionAction;
}
/** Configuration of the app presence detection behavior */
interface MalwarelyticsAndroidAppPresenceDetectionConfig {
    /** Behavior of the detection */
    action: MalwarelyticsAndroidDetectionAction;
    /** This URL will be open in the default browser when app is terminated in case that the `action` is `EXIT`. */
    exitUrl?: string;
    /** List of apps that the SDK is looking for.
     *  When not defined, the default list of remote apps from native SDK is used.
     */
    remoteDesktopApps?: MalwarelyticsAndroidNamedApkItem[];
}
/** Configuration of app the presence of which should be checked. */
interface MalwarelyticsAndroidNamedApkItem {
    /** Defined custom name to be used for the application. */
    displayName: String;
    /** Package name (application ID) of the app. */
    packageName: String;
    /** SHA-1 hash of the app's signature. The signature hash is optional. */
    signatureHash?: String;
}
/**
 * NO_ACTION - do nothing
 * NOTIFY - notify via the observer
 * EXIT - exit the app
 */
type MalwarelyticsAndroidDetectionAction = "NO_ACTION" | "NOTIFY" | "EXIT";
/**
 * NO_ACTION - do nothing
 * BLOCK - block
 */
type MalwarelyticsAndroidBlockAction = "NO_ACTION" | "BLOCK";
/**
 * NO_ACTION - do nothing
 * USE_STEALTHY - use stealthy process name
*/
type MalwarelyticsAndroidProcessNameAction = "NO_ACTION" | "USE_STEALTHY";
/**
 * NOTIFY - notify via the observer
 * EXIT - exit the app
 */
type MalwarelyticsAndroidAdbDetectionAction = "NOTIFY" | "EXIT";
/**
 * NO_ACTION - do nothing
 * NOTIFY - notify via the observer
 */
type MalwarelyticsAndroidSimpleDetectionAction = "NO_ACTION" | "NOTIFY";
/** Configuration of the Malwarelytics SDK for the Apple platform. */
interface MalwarelyticsAppleConfig {
    /**
     * RASP component configuration. If not set, default values are used.
     */
    raspConfig?: MalwarelyticsAppleRaspConfig;
    /**
     * Configuration for the online Malwarelytis service.
     * The default value is `null` which means that by default Malwarelytics does not connect to the online service.
     */
    onlineConfig?: MalwarelyticsAppleOnlineConfig;
}
/**
 * Configuration for the online Malwarelytics service.
 */
interface MalwarelyticsAppleOnlineConfig {
    /**
     * Configuration of the events that are sent to the server.
     */
    eventsConfig?: MalwarelyticsAppleEventConfig;
    /**
     * Configuration of customer grouping and naming in the Malwarelytics web console.
     */
    customerGrouping?: MalwarelyticsAppleCustomerGroupingConfig;
}
/** Configuration of the events collection. */
interface MalwarelyticsAppleEventConfig {
    /** Way to disable event collection in general. The default value is `true`. */
    enableEventCollection?: boolean;
    /** Event will be reported when user takes a screenshot. The default value is `true`. */
    enableScreenshotTakenCollection?: boolean;
}
/** Configuration of customer grouping and naming in the Malwarelytics web console. */
interface MalwarelyticsAppleCustomerGroupingConfig {
    /**
     * Set custom source bundle identifier.
     * The value has to match application credentials defined in the web application.
     *
     * Maximum length of the value is 255 characters.
     */
    sourceBundleId?: string;
    /**
     * Set app bundle identifier to obtain extra granularity
     * of the information displayed in the web application.
     * Distinguishes application purposes or segmentation in one organization.
     *
     * Maximum length of the value is 255 characters.
     */
    appBundleId?: string;
    /**
     * Set audience group ID to obtain extra granularity
     * of the information displayed in the web application.
     * Distinguishes users from different customer systems (RETAIL, CORPORATE, ...).
     *
     * Maximum length of the value is 20 characters.
     */
    audienceGroupId?: string;
}
/** Configuration of the RASP features on the Apple platforms */
interface MalwarelyticsAppleRaspConfig {
    /** Jailbreak detection configuration. The default action is `NOTIFY`. */
    jailbreak?: MalwarelyticsAppleDetectionConfig;
    /** Debugger detection configuration. The default action is `NOTIFY`. */
    debugger?: MalwarelyticsAppleDebuggerDetectionConfig;
    /** everse engineering tools presence detection configuration. The default action is `NOTIFY`. */
    reverseEngineeringTools?: MalwarelyticsAppleDetectionConfig;
    /** HTTP proxy detection configuration. The default action is `NOTIFY`. */
    httpProxy?: MalwarelyticsAppleDetectionConfig;
    /** Repackaging detection configuration. The default action is `NO_ACTION` with empty array of certificates. */
    repackage?: MalwarelyticsAppleRepackageConfig;
    /** Screen capturing detection. The default action is `NOTIFY`. */
    screenCapture?: MalwarelyticsAppleScreenCaptureDetectionConfig;
    /** VPN active detection. The default value is `NOTIFY`. */
    vpnChanged?: MalwarelyticsAppleDetectionConfig;
    /** Call detection. The default value is `NOTIFY`. */
    callDetection?: MalwarelyticsAppleSimpleDetectionConfig;
    /** App presence detection. 3rd party app presence. The default value is `.manual` with empty array of apps. */
    appPresence?: MalwarelyticsAppleAppPresenceDetectionConfig;
}
/** Configuration of the debugger detection behavior */
interface MalwarelyticsAppleDebuggerDetectionConfig {
    /** Behavior of the debugger detection */
    action: MalwarelyticsAppleDebuggerDetectionAction;
    /** This URL will be open in the default browser when app is terminated in case that the `action` is `EXIT`. */
    exitUrl?: string;
}
/** Configuration of the repackaging detection behavior */
interface MalwarelyticsAppleRepackageConfig {
    /** Behavior of the repackaging detection */
    action: MalwarelyticsAppleDetectionAction;
    /**
     * Trusted certificates for ad-hoc or enterprise distribution.
     *
     * This is needed only for non-production distribution.
     *
     * How to retrieve the certificate:
     * 1. Open the Keychain Access application.
     * 2. Find a certificate that will be used to sign your application, for example, “Apple Development: Jan Tester (c)”.
     * 3. Right-click on the item and click “Export…”.
     * 4. Export the certificate in the .cer format.
     * 5. Open up the terminal and cd into the folder with your exported certificate.
     * 6. Encode the certificate in Base64 with cat your_exported.cer | base64.
     */
    base64EncodedTrustedCertificates?: string[];
    /** This URL will be open in the default browser when app is terminated in case that the `action` is `EXIT`. */
    exitUrl?: string;
}
interface MalwarelyticsAppleScreenCaptureDetectionConfig {
    /** Behavior of the detection */
    action: MalwarelyticsAppleScreenCaptureDetectionAction;
    /** This URL will be open in the default browser when app is terminated in case that the `action` is `EXIT`. */
    exitUrl?: string;
    /** Overlay that will be displayed when screen capture is detected in case that the `action` is `HIDE`. */
    overlay?: MalwarelyticsAppleOverlay;
}
/** Configuration of the basic detection behavior */
interface MalwarelyticsAppleDetectionConfig {
    /** Behavior of the detection */
    action: MalwarelyticsAppleDetectionAction;
    /** This URL will be open in the default browser when app is terminated in case that the `action` is `EXIT`. */
    exitUrl?: string;
}
/** Configuration of the simple detection behavior */
interface MalwarelyticsAppleSimpleDetectionConfig {
    /** Behavior of the detection */
    action: MalwarelyticsAppleSimpleDetectionAction;
}
/** Configuration of the app presence detection behavior */
interface MalwarelyticsAppleAppPresenceDetectionConfig {
    /** Behavior of the detection */
    action: MalwarelyticsAppleAppPresenceDetectionAction;
    /** Applications that can be detected on the phone if present. */
    apps: MalwarelyticsAppleDetectableApp[];
}
/** Configuration of the overlay */
interface MalwarelyticsAppleOverlay {
    type: MalwarelyticsAppleOverlayType;
    color?: MalwarelyticsAppleColor;
    image?: MalwarelyticsAppleImage;
}
/**
 * NO_ACTION - do nothing
 * NOTIFY - notify via the observer
 * BLOCK - block the debugger
 * EXIT - exit the app
 */
type MalwarelyticsAppleDebuggerDetectionAction = "NO_ACTION" | "NOTIFY" | "BLOCK" | "EXIT";
/**
 * NO_ACTION - do nothing
 * NOTIFY - notify via the observer
 * HIDE - hide app's content with overlay when screen capture is detected
 * EXIT - exit the app
 */
type MalwarelyticsAppleScreenCaptureDetectionAction = "NO_ACTION" | "NOTIFY" | "HIDE" | "EXIT";
/**
 * NO_ACTION - do nothing
 * NOTIFY - notify via the observer
 * EXIT - exit the app
 */
type MalwarelyticsAppleDetectionAction = "NO_ACTION" | "NOTIFY" | "EXIT";
/**
 * NO_ACTION - do nothing
 * NOTIFY - notify via the observer
 */
type MalwarelyticsAppleSimpleDetectionAction = "NO_ACTION" | "NOTIFY";
/**
 * MANUAL - automatic detection is turned off, you can do a manual check
 * NOTIFY - notify via the observer
 */
type MalwarelyticsAppleAppPresenceDetectionAction = "MANUAL" | "NOTIFY";
/**
 * DEFAULT - default cover with solid color and application icon
 * COLOR - cover with a solid color
 * IMAGE - cover with an image
 */
type MalwarelyticsAppleOverlayType = "DEFAULT" | "COLOR" | "IMAGE";
/**
 * UIColor abstraction for configuration
 */
interface MalwarelyticsAppleColor {
    red: number;
    green: number;
    blue: number;
    alpha: number;
}
/**
 * UIImage abstraction for configuration
 */
interface MalwarelyticsAppleImage {
    name: string;
}
/**
 * Configuration of application that can be detected on the phone if present.
 */
interface MalwarelyticsAppleDetectableApp {
    deeplinkProtocols: string[];
    name: string;
    category: MalwarelyticsAppleDetectableAppCategory;
    tag?: string;
}
/**
 * Category of MalwarelyticsAppleDetectableApp
 * REMOTE_DESKTOP - Remote desktop apps are apps that can screen cast phone screen.
 */
type MalwarelyticsAppleDetectableAppCategory = "REMOTE_DESKTOP";
/**
 * Malwarelytics configuration.
 */
interface MalwarelyticsConfig {
    /** Custom identifier of the user. You can set it later via setClientId method. */
    clientId?: string;
    /** Custom identifier of the device. You can set it later via setDeviceId method. */
    deviceId?: string;
    /** Configuration on the Android platform. Default configuration is used when not set. */
    androidConfig?: MalwarelyticsAndroidConfig;
    /** Configuration on Apple platforms. Default configuration is used when not set. */
    appleConfig?: MalwarelyticsAppleConfig;
}
/**
 * Each type matches to specific error case
 */
type MalwarelyticsErrorType = "PLUGIN_UNKNOWN_ACTION" | "PLUGIN_ALREADY_INITIALIZED" | "PLUGIN_NOT_INITIALIZED" | "MISSING_ARGUMENTS" | "INITIALIZE_MISSING_CREDENTIALS" | "INITIALIZE_WRONG_CONFIG" | "TRIGGER_SMART_PROTECTION_UPDATE_FAILED" | "TRIGGER_SMART_PROTECTION_FAILED" | "UTILS_LANG_CHANGE_FAILED" | "THREAT_LIST_FAILED" | "APK_INFO_NOT_AVAILABLE" | "RASP_UNKNOWN_DETECTION";
declare class MalwarelyticsError {
    readonly type: MalwarelyticsErrorType;
    readonly data?: any;
    readonly description: string;
    constructor(type: MalwarelyticsErrorType, description: string, data?: any);
}
/**
 * JavaScript wrapper around native kotlin/swift Malwarelytics code.
 * Malwarelytics plugin can be accessed in cordova app via `window.plugins.malwarelytics` property.
 */
declare class MalwarelyticsPlugin extends __MPService {
    /** Features for the Android platform. */
    readonly android: MalwarelyticsAndroid;
    /** Features for the Apple platforms. */
    readonly apple: MalwarelyticsApple;
    /**
     * If the malwarelytics are initialized.
     */
    isInitialized(): Promise<boolean>;
    /**
     * Initializes Malwarelytics with provided configuration.
     * Note that username and password needs to be set inside the plugin kotlin file MalwarelyticsCredentials.kt
     *
     * @param config Configuration file
     */
    initialize(config: MalwarelyticsConfig): Promise<void>;
    /**
     * Sets new client id that will be sent to the backend for user identification.
     * Pass null to remove the current client id (for example when user logged-out).
     *
     * @param clientId Client id. Null for deleting the value
     */
    setClientId(clientId: string): Promise<void>;
    /**
     * Sets new device id that will be sent to the backend for user identification.
     * Pass null to remove the current device id.
     *
     * @param deviceId Device id. Null for deleting the value
     */
    setDeviceId(deviceId: string): Promise<void>;
}
/**
 * Information about android apk.
 */
interface ApkInfo {
    /**
     * Application name as displayed in the system.
     */
    label: String;
    /**
     * Base64 encode PNG icon in the original size.
     * You can use it in html as `<img src="data:image/jpeg;base64,${apkInfo.icon}" width="96" />`
     */
    icon?: String;
}
/**
 * Result of initialization on Android.
 */
declare enum InitializationResult {
    SUCCESS = "SUCCESS",
    TEMPORARY_OFFLINE_MODE = "TEMPORARY_OFFLINE_MODE",
    PERMANENT_OFFLINE_MODE = "PERMANENT_OFFLINE_MODE"
}
/**
 * Result of single smart protection udpdate.
 */
interface SmartProtectionResult {
    /**
     * Wether was the UI displayed. A UI can be either a threat screen or a notification.
     */
    uiDisplayed: Boolean;
    /**
     * Whether data update from server succeeded.
     */
    onlineUpdateSucceeded: Boolean;
    /**
     * Whether evaluation of threats succeeded.
     */
    evaluationSucceeded: Boolean;
}
/**
 * An apk with analyzed threats.
 */
interface ApkThreat {
    /** Package name (application Id) of the app posing a threat to the current app. */
    readonly packageName: string;
    /** Threat index indicating severity of the threat. */
    readonly threatIndex: ThreatIndex;
    /** Evaluated threat index indicating severity of the threat. */
    readonly evaluatedThreatIndex: ThreatIndex;
    /** Suggested threat index. If the value is `UNKNOWN` then there's no suggestion. */
    readonly suggestedThreatIndex: ThreatIndex;
    /** Optional name of malware detection. This is not bound to the thratIndex, can appear independently. */
    readonly malwareDetectionName?: string;
    /** Set of recommended mitigations for handling the threat. */
    readonly mitigations: ThreatMitigation[];
    /** Evaluated threat reasons marking what is dangerous about the app. */
    readonly reasons: ThreatReason[];
    /** Store the app was installed from (for example google play). */
    readonly threatInstaller?: ThreatInstaller;
    /** List of malware flags - malware types and malware families.  */
    readonly flags: MalwareFlag[];
}
/** Flag designating malware info. */
interface MalwareFlag {
    readonly name: string;
    readonly type: MalwareFlagType;
}
/** Type of MalwareFlag. */
declare enum MalwareFlagType {
    /** Unknown type of malware flag. */
    UNKNOWN = "UNKNOWN",
    /** Name of the malware family. */
    MALWARE_FAMILY = "MALWARE_FAMILY",
    /** Type of the malware, relates with used attack techniques. */
    MALWARE_TYPE = "MALWARE_TYPE"
}
/**
 * A threat level that is posed by an app.
 *
 * MALWARE:
 * The found threats clearly indicate that the app is a malware.
 *
 * HIGHLY_DANGEROUS:
 * The found threats indicate that the app is highly dangerous
 * to the current app.
 * It uses multiple potential attack vectors
 * including techniques directly targeting the current app.
 *
 * DANGEROUS:
 * The found threats indicate that the app is dangerous
 * to the current app.
 * Is uses multiple potential attack vectors.
 * However, no technique directly targeting the current app was detected.
 *
 * POTENTIALLY_UNWANTED_APP:
 * The found threats indicate that the app might be potentially dangerous.
 * For example it declares potentially dangerous permissions.
 * However it it quite possible that the app is legitimate.
 *
 * SAFE:
 * There are no found threats.
 *
 * UNKNOWN:
 * The threat is unknown.
 * The app was probably not found.
 * In case of suggestions, there's none.
 */
type ThreatIndex = "MALWARE" | "HIGHLY_DANGEROUS" | "DANGEROUS" | "POTENTIALLY_UNWANTED_APP" | "SAFE" | "UNKNOWN";
/**
 * Installer app of an apk.
 *
 * STORE_GOOGLE_PLAY: The app was installed via Google Play
 * STORE_HUAWEI_APP_GALLERY: The app was installed via Huawei App Gallery
 * STORE_SAMSUNG_GALAXY_STORE: The app was installed via Samsung Galaxy Store
 * STORE_APTOIDE: The app was installed via Aptoide
 */
type ThreatInstaller = "STORE_GOOGLE_PLAY" | "STORE_HUAWEI_APP_GALLERY" | "STORE_SAMSUNG_GALAXY_STORE" | "STORE_APTOIDE";
type ThreatMitigation = "WARNING_SCREEN" | "NOTIFICATION" | "SHOW_WEB" | "KILL_APP" | "KILL_APP_SHOW_WEB";
/**
 * Evaluated flag for an apk threat.
 * The flag risk the other app is posing.
 *
 * ACCESSIBILITY: Accesibility
 * SMS_ACCESS: Read sms, receive sms, notification listener
 * SCREEN_OVERRIDE: Task hijacking, screen overlay
 * INSTALLER: Can install apps
 * UNINSTALLER: Can uninstall apps
 * EVADER: Hides it's internals/function
 * OUTSIDE_GOOGLE_PLAY: Not installed via Google Play
 * CALLER: Can play with your calls, e.g. it can setup a call forwarding of your calls
 * PRELOADED_APP: The app is preloaded on the device
 * PRIVILEGED_APP: The app is privileged (system privileges)
 * DEVELOPMENT_OR_TEST: The app is debuggable
 *
 */
type ThreatReason = "ACCESSIBILITY" | "SMS_ACCESS" | "SCREEN_OVERRIDE" | "INSTALLER" | "UNINSTALLER" | "EVADER" | "OUTSIDE_GOOGLE_PLAY" | "CALLER" | "PRELOADED_APP" | "PRIVILEGED_APP" | "DEVELOPMENT_OR_TEST";
/**
 * Info about observed update.
 *
 * Returned @see updateResult corresponds to these data:
 * - {@link UpdateResult.SUCCESS}:
 *     @see failureReason is null
 * - {@link UpdateResult.PARTIAL_SUCCESS}:
 *     @see failureReason is not null
 *     and @see updatedApps is not empty
 * - {@link UpdateResult.FAILURE}:
 *     and @see failureReason is not null
 *     and @see updatedApps is empty
 *
 * Partially successful update can happen when an error occurs while storing the suggestions locally.
 * In such case, suggestions for only a fraction of apps were stored.
 */
interface ObservedUpdateInfo {
    /** Result of the update. */
    readonly updateResult: UpdateResult;
    /** Type of update performed. */
    readonly updateType: UpdateType;
    /** List of apps that were checked in the update. */
    readonly checkedApps: [string];
    /** List of apps that were successfully updated in the update. */
    readonly updatedApps: [string];
    /** String representation of an error that occurred during processing of the update. */
    readonly failureReason?: string;
}
/** Result of an update. */
declare enum UpdateResult {
    /**
     * Successful update.
     *
     * All apps were successfully updated without any error.
     */
    SUCCESS = "SUCCESS",
    /**
     * Partially successful update.
     *
     * Some apps were successfully updated but not all of them.
     * Some apps couldn't be successfully updated for some reason.
     */
    PARTIAL_SUCCESS = "PARTIAL_SUCCESS",
    /**
     * Failure.
     *
     * Update failed for some reason.
     */
    FAILURE = "FAILURE"
}
/**
 * Info about updates.
 *
 * The update info contains data about last successes and failures for each [UpdateType].
 */
interface UpdateInfo {
    /**
      * Map of success info data for each @see UpdateType.
      * Only updates with @see UpdateResult.SUCCESS are returned here.
      */
    readonly successfulUpdates: Map<UpdateType, UpdateInfoSuccess>;
    /**
     * Map of failure info data for each @see UpdateType.
     * Info about updates with results @see UpdateResult.FAILURE and @see UpdateResult.PARTIAL_SUCCESS is returned here.
     */
    readonly failedUpdates: Map<UpdateType, UpdateInfoFailure>;
}
/** Type of update. */
declare enum UpdateType {
    /** Updating only a selection of apps. Happens for example when new app is installed or an app is updated. */
    PARTIAL = "PARTIAL",
    /** Updating all apps. */
    FULL = "FULL"
}
/** Info about the last successful update. */
interface UpdateInfoSuccess {
    /** Unix timestamp of the last successful update. */
    readonly lastSuccessTimestamp?: number;
    /** Number of apps that were checked in the last successful update. */
    readonly lastSuccessCheckCount: number;
    /** Number of apps that had suggestions updated in the last successful update. */
    readonly lastSuccessUpdatedCount: number;
}
/** Info about the last failed update. */
interface UpdateInfoFailure {
    /** Unix timestamp of the last failed update. */
    readonly lastFailureTimestamp?: number;
    /** Reason for the last update failure. */
    readonly lastFailureReason?: string;
}
interface ActiveCallDetection {
    callState: CallState;
}
declare enum CallState {
    IDLE = "IDLE",
    RINGING = "RINGING",
    ACTIVE_CALL = "ACTIVE_CALL",
    ACTIVE_COMMUNNICATION = "ACTIVE_COMMUNNICATION",
    CALL_SCREENING = "CALL_SCREENING",
    ACTIVE_CALL_REDIRECT = "ACTIVE_CALL_REDIRECT",
    ACTIVE_COMMUNICATION_REDIRECT = "ACTIVE_COMMUNICATION_REDIRECT",
    UNKNOWN = "UNKNOWN"
}
/** App presence detection data. */
interface AppPresenceDetection {
    remoteDesktopApps: [NamedApkItemInfo];
}
/** Rasp detection app item. */
interface NamedApkItemInfo {
    /** Display name item as defined in the configuration. */
    displayName: string;
    /** Obtained application name. */
    appName: string;
    /** Package name (application ID) of the app. */
    packageName: string;
    /** Version name. */
    versionName: string;
    /** Version code. */
    versionCode: number;
    /** Base64 encoded SHA-1 signature hash. */
    signatureHash: string;
}
interface BiometryDetection {
    biometricStatus: BiometricStatus;
    androidxLibStatus: number;
}
declare enum BiometricStatus {
    CONFIGURED = "CONFIGURED",
    UNKNOWN = "UNKNOWN",
    UNSUPPORTED = "UNSUPPORTED",
    CURRENTLY_UNAVAILABLE = "CURRENTLY_UNAVAILABLE",
    NONE_ENROLLED = "NONE_ENROLLED"
}
interface DebuggerDetection {
    isDebuggerAttached: boolean;
    isWaitingForDebugger: boolean;
    debuggerType: [DebuggerType];
}
declare enum DebuggerType {
    JAVA = "JAVA",
    NATIVE = "NATIVE"
}
interface EmulatorDetection {
    isEmulator: boolean;
    detectedEmulatorType?: EmulatorType;
    emulatorDetectionProofs: [EmulatorDetectionProof];
}
declare enum EmulatorType {
    AVD = "AVD",
    GENYMOTION = "GENYMOTION",
    OTHER = "OTHER"
}
declare enum EmulatorDetectionProof {
    EDP_01 = "EDP_01",
    EDP_02 = "EDP_02",
    EDP_03 = "EDP_03",
    EDP_04 = "EDP_04",
    EDP_05 = "EDP_05",
    EDP_06 = "EDP_06",
    EDP_07 = "EDP_07",
    EDP_08 = "EDP_08",
    EDP_09 = "EDP_09",
    EDP_10 = "EDP_10"
}
/**
 * Http Proxy data.
 */
interface HttpProxyDetection {
    /** Whether the proxy data indicate that a proxy is enabled. */
    isHttpProxyEnabled: boolean;
    isUsingAutoConfig: boolean;
    /** Host of the proxy server or null if proxy is not enabled. */
    host?: string;
    /** Port of the proxy server or null if proxy is not enabled. */
    port?: number;
    /** Comma separated list of host for which the proxy is ignored or null if there are no excluded hosts. */
    exclusionList?: string;
    /** he URL of the current PAC script or null if there is no PAC script. */
    pacFileUrl?: string;
}
declare enum RaspCallbackType {
    DEBUGGER = "DEBUGGER",
    EMULATOR = "EMULATOR",
    REPACKAGING = "REPACKAGING",
    ROOT = "ROOT",
    SCREEN_SHARING = "SCREEN_SHARING",
    SCREEN_READER = "SCREEN_READER",
    TAPJACKING = "TAPJACKING",
    HTTP_PROXY = "HTTP_PROXY",
    VPN = "VPN",
    ADB_STATUS = "ADB_STATUS",
    ACTIVE_CALL = "ACTIVE_CALL",
    APP_PRESENCE = "APP_PRESENCE"
}
declare enum RepackagingResult {
    REPACKAGED_APP = "REPACKAGED_APP",
    ORIGINAL_APP = "ORIGINAL_APP",
    INVALID_CONFIG = "INVALID_CONFIG"
}
interface RootDetection {
    isRooted: boolean;
    isRootCloaked: boolean;
    rootDetectionProofs: [RootDetectionProof];
    rootDetectionConfidence: number;
    rootCloakDetectionConfidence: number;
}
declare enum RootDetectionProof {
    RDP_01 = "RDP_01",
    RDP_02 = "RDP_02",
    RDP_03 = "RDP_03",
    RDP_04 = "RDP_04",
    RDP_05 = "RDP_05",
    RDP_06 = "RDP_06",
    RDP_07 = "RDP_07",
    RDP_08 = "RDP_08",
    RDP_09 = "RDP_09",
    RDP_10 = "RDP_10",
    RDP_11 = "RDP_11",
    RDP_12 = "RDP_12"
}
/** Screen reader blocking data. */
interface ScreenReaderDetection {
    /** Whether a not allowed screen reader is enabled. */
    isNotAllowedScreenReaderEnabled: boolean;
    /** Not allowed screen readers that are enabled. Identified by their package names (application IDs). */
    notAllowedScreenReaders: [string];
    /** List of all enabled screen readers on the device. */
    enabledScreenReaders: [string];
    /** List of all installed screen readers on the device. */
    installedScreenReaders: [string];
}
/** Screen sharing detection data. */
interface ScreenSharingDetection {
    /** Number of detected displays that the content is displayed on. */
    numberOfDisplays: number;
    /** Whether a device screen is being shared (mirror) elsewhere. */
    isScreenShared: number;
    /** Transient data containing information about detected transient changes. */
    transientData: TransientScreenSharingData;
    /** Whether the detection result is problematic for the app. */
    isProblematic: boolean;
    /** Whether the detection result indicates a transient change. */
    isTransientChange: boolean;
}
/** Obtained transient data. */
interface TransientScreenSharingData {
    /** Whether an added display has just been detected. */
    displayAdded: boolean;
    /** Whether a removed display has just been detected. */
    displayRemoved: boolean;
}
interface TapjackingDetection {
    isTapjackingBlocked: boolean;
    tapjackingCapableApps: [string];
}
