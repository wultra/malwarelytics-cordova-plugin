declare enum __MPRaspRetection {
    ROOT_DETECTION = "ROOT_DETECTION",
    IS_ROOTED = "IS_ROOTED",
    IS_EMULATOR = "IS_EMULATOR",
    EMULATOR_INFO = "EMULATOR_INFO",
    IS_DEBUGGER = "IS_DEBUGGER",
    DEBUGGER_INFO = "DEBUGGER_INFO",
    REPACKAGE_INFO = "REPACKAGE_INFO",
    IS_SCREEN_SHARED = "IS_SCREEN_SHARED",
    SCREEN_SHARED_INFO = "SCREEN_SHARED_INFO",
    SCREEN_LOCK_ENABLED = "SCREEN_LOCK_ENABLED",
    PLAY_PROTECT_ENABLED = "PLAY_PROTECT_ENABLED"
}
declare class __MPWrapper {
    readonly pluginName = "MalwarelyticsPlugin";
    constructor();
    call<T>(name: string, success: successCallback<T>, error: errorCallback, ...args: any[]): void;
    private createFailCallback;
}
/**
 * Malwarelytics configuration.
 */
interface MalwarelyticsConfig {
    /** Custom identifier of the user. You can set it later via setClientId method. */
    clientId?: string;
    /** ISO 639-1 language code that the app will be used for UI localization. */
    languageCode?: string;
    /** Antivirus component configuration. If not set, default values are used. */
    antivirus?: AntivirusConfig;
    /** RASP component configuration. If not set, default values are used. */
    rasp?: RaspConfig;
}
/** Antivirus component configuration */
interface AntivirusConfig {
    /** Malwarelytics in silent mode does not show any UI. Default is true. */
    enableSilentMode?: boolean;
    /** How often will be antivirus database checked (hourly). Default is 48 hours. */
    onlineCheckIntervalHours?: number;
    /** If databse should be performend on SDK initialize. Default is true. */
    updateOnInitialize?: boolean;
}
interface RaspConfig {
    /** Turn on/off automatic emulation detection. It is on by default. */
    checkEmulator?: boolean;
    /** Whether to terminate the app when emulator is automatically detected. It is off by default. */
    exitOnEmulator?: boolean;
    /** Turns on/off automatic root detection. It is on by default. */
    checkRoot?: boolean;
    /** Whether to terminate the app when rooted device is automatically detected. It is off by default. */
    exitOnRoot?: boolean;
    /**
     * Minimum confidence value of heuristic root detections that triggers app termination.
     *
     * Works only if exitOnRoot is true. Possible values are between 0.0 (inclusive) and 1.0 (inclusive). The default value is 1.0.
     */
    exitOnRootMinConfidence?: number;
    /** Turns on/off automatic detection of attached debuggers. It is on by default. */
    checkDebugger?: boolean;
    /** Whether to terminate the app when an attached debugger is automatically detected. It is off by default. */
    exitOnDebugger?: boolean;
    /**
     * Turns on/off automatic repackaging detection.
     *
     * It is on by default but works only if signatureHash is set.
     */
    checkRepackaging?: boolean;
    /**
     * Whether to terminate the app when repackaging is automatically detected.
     *
     * It is on by default but works only if signatureHash is set.
     */
    exitOnRepackaging?: boolean;
    /**
     * SHA-1 of signing certificate(s). One or more values can be set.
     *
     * Expecting lowercase hex value without any byte separators. No default value is set.
     */
    signatureHash?: string;
    /** Turns on/off automatic screen sharing detection. It is on by default. */
    checkScreenSharing?: boolean;
    /** Whether to terminate teh app when screen sharing is automatically detected. It is off by default. */
    exitOnScreenSharing?: boolean;
    /** Turns on/off blocking taking screenshots and screen recording. It is on by default. */
    blockScreenshots?: boolean;
    /**
     * Turn on/off blocking screen readers. It is on by default.
     *
     * Screen readers are blocked only when an enabled screen reader is detected that is not allowed in allowedScreenReaders.
     */
    blockScreenReaders?: boolean;
    /** Defines collection of allowed screen readers. It is empty by default. */
    allowedScreenReaders?: Apk[];
    /** Sets custom name to be used for the app process. When set, turns off useStealthyProcessName. */
    customProcessName?: string;
    /**
     * Whether to use a stealthy name for the app's process. It is on by default.
     *
     * When true a name is selected randomly from a list of stealthy process names. It is turned off when customProcessName is set.
     */
    useStealthyProcessName?: boolean;
}
interface Apk {
    packageName: string;
    signatureHash?: string;
}
/**
 * Each type matches to specific error case
 */
declare type MalwarelyticsErrorType = "PLUGIN_UNKNOWN_ACTION" | "PLUGIN_ALREADY_INITIALIZED" | "PLUGIN_NOT_INITIALIZED" | "MISSING_ARGUMENTS" | "INITIALIZE_MISSING_CREDENTIALS" | "INITIALIZE_WRONG_CONFIG" | "TRIGGER_SMART_PROTECTION_UPDATE_FAILED" | "TRIGGER_SMART_PROTECTION_FAILED" | "UTILS_LANG_CHANGE_FAILED" | "THREAT_LIST_FAILED" | "APK_INFO_NOT_AVAILABLE";
declare class MalwarelyticsError {
    readonly type: MalwarelyticsErrorType;
    readonly data?: any;
    readonly description: string;
    constructor(type: MalwarelyticsErrorType, description: string, data?: any);
}
/**
 * Javascript wrapper around native kotlin malwarelytics code.
 * Malwarelytics plugin can be accessed in cordova app via `window.plugins.malwarelytics` property.
 */
declare class MalwarelyticsPlugin {
    private readonly w;
    /** Features for antivirus component */
    antivirus: Antivirus;
    /** Features for RASP component. */
    rasp: Rasp;
    /**
     * If the malwarelytics are initialized.
     * @param success Returns the result
     * @param error Called on error
     */
    isInitialized(success: successCallback<boolean>, error?: errorCallback): void;
    /**
     * Initializes themalwarelytics with provided configuration.
     * Note that username and password needs to be set inside the plugin kotlin file MalwarelyticsCredentials.kt
     *
     * @param config Configuration file
     * @param success When the configuration was success
     * @param error Called on error
     */
    initialize(config: MalwarelyticsConfig, success?: successCallback, error?: errorCallback): void;
    /**
     * Sets new clinet id that will be sent to the backend for user identification.
     * Pass null to remove the current client id (for example when user logged-out).
     *
     * @param clientId Client id. Null for deleting the value
     * @param success When the id was set
     * @param error Called on error
     */
    setClientId(clientId: string, success?: successCallback, error?: errorCallback): void;
    /**
     * Utility helper method that changes to language of the Malwarelytics UI.
     * The language code follows the ISO 639-1 standard.
     *
     * Note that the language configuration is not persisted and you'll need to set it
     * every time the app is started.
     *
     * @param language ISO 639-1 language code
     * @param success When language change was success
     * @param error  When language change failed
     */
    changeAppLanguage(language: string, success?: successCallback, error?: errorCallback): void;
}
declare class Antivirus {
    private w;
    constructor(w: __MPWrapper);
    /**
     * Schedules a job that will execute smart protection run. Note that this is asynchronous and
     * can take some time.
     *
     * @param success When the job was scheduled
     * @param error Called on error
     */
    triggerSmartProtection(success?: successCallback, error?: errorCallback): void;
    /**
     * Returns list of all applications with the malware evaluation.
     *
     * @param success APKs
     * @param error Called on error
     */
    getThreatList(success?: successCallback<{
        items: ApkThreat[];
    }>, error?: errorCallback): void;
    /**
     * Gets more information for the package name of the application.
     *
     * @param packageName Package name of the application
     * @param success Information about the application with the label and icon.
     * @param error Called on error
     */
    getApkInfo(packageName: String, success?: successCallback<ApkInfo>, error?: errorCallback): void;
}
declare class Rasp {
    private w;
    constructor(w: __MPWrapper);
    getRootDetection(success: successCallback<RootDetection>, error?: errorCallback): void;
    isDeviceRooted(success: successCallback<boolean>, error?: errorCallback): void;
    getEmulatorDetection(success: successCallback<EmulatorDetection>, error?: errorCallback): void;
    isDeviceEmulator(success: successCallback<boolean>, error?: errorCallback): void;
    getDebuggerDetection(success: successCallback<DebuggerDetection>, error?: errorCallback): void;
    isDebuggerAttached(success: successCallback<boolean>, error?: errorCallback): void;
    getAppRepackaged(success: successCallback<RepackagingResult>, error?: errorCallback): void;
    getScreenSharingDetection(success: successCallback<ScreenSharingDetection>, error?: errorCallback): void;
    isScreenShared(success: successCallback<boolean>, error?: errorCallback): void;
    isDeviceUsingScreenLock(success: successCallback<boolean>, error?: errorCallback): void;
    isPlayProtectEnabled(success: successCallback<boolean>, error?: errorCallback): void;
    private getInfo;
}
declare function wrapBoolResp(success: successCallback<boolean>): (data: number) => void;
declare type successCallback<T = void> = (result: T) => void;
declare type errorCallback = (err: MalwarelyticsError) => void;
declare var module: any;
/**
 * Information about android apk.
 */
interface ApkInfo {
    /**
     * Application name as displayed in the system.
     */
    label: String;
    /**
     * Base64 encode PNG icon in the original size.
     * You can use it in html as `<img src="data:image/jpeg;base64,${apkInfo.icon}" width="96" />`
     */
    icon?: String;
}
/**
 * An apk with analyzed threats.
 */
interface ApkThreat {
    /** Package name (application Id) of the app posing a threat to the current app. */
    packageName: string;
    /** Threat index indicating severity of the threat. */
    threatIndex: ThreatIndex;
    /** Optional name of malware detection. This is not bound to the thratIndex, can appear independently. */
    malwareDetectionName?: string;
    /** Set of recommended mitigations for handling the threat. */
    mitigations: ThreatMitigation[];
    /** Evaluated threat reasons marking what is dangerous about the app. */
    reasons: ThreatReason[];
    /** Store the app was installed from (for example google play). */
    threatInstaller: ThreatInstaller;
}
/**
 * A threat level that is posed by an app.
 *
 * MALWARE:
 * The found threats clearly indicate that the app is a malware.
 *
 * HIGHLY_DANGEROUS:
 * The found threats indicate that the app is highly dangerous
 * to the current app.
 * It uses multiple potential attack vectors
 * including techniques directly targeting the current app.
 *
 * DANGEROUS:
 * The found threats indicate that the app is dangerous
 * to the current app.
 * Is uses multiple potential attack vectors.
 * However, no technique directly targeting the current app was detected.
 *
 * POTENTIALLY_UNWANTED_APP:
 * The found threats indicate that the app might be potentially dangerous.
 * For example it declares potentially dangerous permissions.
 * However it it quite possible that the app is legitimate.
 *
 * SAFE:
 * There are no found threats.
 *
 * UNKNOWN:
 * The threat is unknown.
 * The app was probably not found.
 * In case of suggestions, there's none.
 */
declare type ThreatIndex = "MALWARE" | "HIGHLY_DANGEROUS" | "DANGEROUS" | "POTENTIALLY_UNWANTED_APP" | "SAFE" | "UNKNOWN";
/**
 * Installer app of an apk.
 *
 * STORE_GOOGLE_PLAY: The app was installed via Google Play
 * STORE_HUAWEI_APP_GALLERY: The app was installed via Huawei App Gallery
 * STORE_SAMSUNG_GALAXY_STORE: The app was installed via Samsung Galaxy Store
 * STORE_APTOIDE: The app was installed via Aptoide
 */
declare type ThreatInstaller = "STORE_GOOGLE_PLAY" | "STORE_HUAWEI_APP_GALLERY" | "STORE_SAMSUNG_GALAXY_STORE" | "STORE_APTOIDE";
declare type ThreatMitigation = "WARNING_SCREEN" | "NOTIFICATION" | "SHOW_WEB" | "KILL_APP" | "KILL_APP_SHOW_WEB";
/**
 * Evaluated flag for an apk threat.
 * The flag risk the other app is posing.
 *
 * ACCESSIBILITY: Accesibility
 * SMS_ACCESS: Read sms, receive sms, notification listener
 * SCREEN_OVERRIDE: Task hijacking, screen overlay
 * INSTALLER: Can install apps
 * UNINSTALLER: Can uninstall apps
 * EVADER: Hides it's internals/function
 * OUTSIDE_GOOGLE_PLAY: Not installed via Google Play
 * CALLER: Can play with your calls, e.g. it can setup a call forwarding of your calls
 * PRELOADED_APP: The app is preloaded on the device
 * PRIVILEGED_APP: The app is privileged (system privileges)
 * DEVELOPMENT_OR_TEST: The app is debuggable
 *
 */
declare type ThreatReason = "ACCESSIBILITY" | "SMS_ACCESS" | "SCREEN_OVERRIDE" | "INSTALLER" | "UNINSTALLER" | "EVADER" | "OUTSIDE_GOOGLE_PLAY" | "CALLER" | "PRELOADED_APP" | "PRIVILEGED_APP" | "DEVELOPMENT_OR_TEST";
interface DebuggerDetection {
    isDebuggerAttached: boolean;
    isWaitingForDebugger: boolean;
    debuggerType: [DebuggerType];
}
declare enum DebuggerType {
    JAVA = "JAVA",
    NATIVE = "NATIVE"
}
interface EmulatorDetection {
    isEmulator: boolean;
    detectedEmulatorType?: EmulatorType;
}
declare enum EmulatorType {
    AVD = "AVD",
    GENYMOTION = "GENYMOTION",
    OTHER = "OTHER"
}
declare enum RepackagingResult {
    REPACKAGED_APP = "REPACKAGED_APP",
    ORIGINAL_APP = "ORIGINAL_APP",
    INVALID_CONFIG = "INVALID_CONFIG"
}
interface RootDetection {
    isRooted: boolean;
    isRootCloaked: boolean;
    rootDetectionProofs: [RootDetectionProof];
    rootDetectionConfidence: number;
    rootCloakDetectionConfidence: number;
}
declare enum RootDetectionProof {
    RDP_01 = "RDP_01",
    RDP_02 = "RDP_02",
    RDP_03 = "RDP_03",
    RDP_04 = "RDP_04",
    RDP_05 = "RDP_05",
    RDP_06 = "RDP_06",
    RDP_07 = "RDP_07",
    RDP_08 = "RDP_08",
    RDP_09 = "RDP_09",
    RDP_10 = "RDP_10",
    RDP_11 = "RDP_11",
    RDP_12 = "RDP_12"
}
interface ScreenSharingDetection {
    numberOfDisplays: number;
    isScreenShared: number;
}
